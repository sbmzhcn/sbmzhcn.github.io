<!DOCTYPE html><html class="theme-next pisces use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/logo.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png?v=5.1.4"><link rel="mask-icon" href="/logo.png?v=5.1.4" color="#222"><meta name="keywords" content="Google SEO, 互联网营销, 工业品营销, 矿山机械"><link rel="alternate" href="/atom.xml" title="Ray's Blog" type="application/atom+xml"><meta name="description" content="Google SEO|互联网营销|工业品营销|矿山机械电子商务|B2B、SEM、社交、EDM邮件营销、市场营销"><meta property="og:type" content="website"><meta property="og:title" content="Ray&#39;s Blog"><meta property="og:url" content="https://www.love4026.org/page/8/index.html"><meta property="og:site_name" content="Ray&#39;s Blog"><meta property="og:description" content="Google SEO|互联网营销|工业品营销|矿山机械电子商务|B2B、SEM、社交、EDM邮件营销、市场营销"><meta property="og:locale" content="zh-Hans"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Ray&#39;s Blog"><meta name="twitter:description" content="Google SEO|互联网营销|工业品营销|矿山机械电子商务|B2B、SEM、社交、EDM邮件营销、市场营销"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://www.love4026.org/page/8/"><title>Google SEO|互联网营销|工业品营销|矿山机械电子商务|B2B、SEM、社交、EDM邮件营销、市场营销 - Ray's Blog</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Ray's Blog</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">Google SEO|互联网营销|工业矿山机械</h1></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-友情链接"><a href="/links/" rel="section"><i class="menu-item-icon fa fa-fw fa-link"></i><br> 友情链接</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.love4026.org/313896/pythonrequests识别网页编码bug/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ray Chang"><meta itemprop="description" content="Think Difficulty"><meta itemprop="image" content="/logo.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Ray's Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/313896/pythonrequests识别网页编码bug/" itemprop="url">python requests识别网页编码bug</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-08-05T22:00:33+08:00">2014-08-05</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/转载/" itemprop="url" rel="index"><span itemprop="name">转载</span></a></span></span> <span class="post-meta-divider">|</span><span class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">575</span></span></div></header><div class="post-body" itemprop="articleBody"><p>Requests 使用的是 urllib3，因此继承了它的所有特性。Requests 支持 HTTP 连接保持和连接池，支持使用 cookie 保持会话，支持文件上传，支持自动确定响应内容的编码，支持国际化的 URL 和 POST 数据自动编码。现代、国际化、人性化。</p><p>最近在使用Requests的过程中发现一个问题，就是抓去某些中文网页的时候，出现乱码，打印encoding是ISO-8859-1。为什么会这样呢？通过查看源码，我发现默认的编码识别比较简单，直接从响应头文件的Content-Type里获取，如果存在charset，则可以正确识别，如果不存在charset但是存在text就认为是ISO-8859-1，见utils.py。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_encoding_from_headers</span><span class="params">(headers)</span>:</span></span><br><span class="line">    <span class="string">"""Returns encodings from given HTTP Header Dict.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param headers: dictionary to extract encoding from.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    content_type = headers.get(<span class="string">'content-type'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> content_type:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    content_type, params = cgi.parse_header(content_type)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'charset'</span> <span class="keyword">in</span> params:</span><br><span class="line">        <span class="keyword">return</span> params[<span class="string">'charset'</span>].strip(<span class="string">"'\""</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'text'</span> <span class="keyword">in</span> content_type:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'ISO-8859-1'</span></span><br></pre></td></tr></table></figure><p>其实Requests提供了从内容获取编码，只是在默认中没有使用，见utils.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_encodings_from_content</span><span class="params">(content)</span>:</span></span><br><span class="line">    <span class="string">"""Returns encodings from given content string.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param content: bytestring to extract encodings from.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    charset_re = re.compile(<span class="string">r'&amp;lt;meta.*?charset=["\']*(.+?)["\'&gt;]'</span>, flags=re.I)</span><br><span class="line">    pragma_re = re.compile(<span class="string">r'&amp;lt;meta.*?content=["\']*;?charset=(.+?)["\'&gt;]'</span>, flags=re.I)</span><br><span class="line">    xml_re = re.compile(<span class="string">r'^&amp;lt;\?xml.*?encoding=["\']*(.+?)["\'&gt;]'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (charset_re.findall(content) +</span><br><span class="line">            pragma_re.findall(content) +</span><br><span class="line">            xml_re.findall(content))</span><br></pre></td></tr></table></figure><p>还提供了使用chardet的编码检测，见models.py:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apparent_encoding</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""The apparent encoding, provided by the lovely Charade library</span></span><br><span class="line"><span class="string">    (Thanks, Ian!)."""</span></span><br><span class="line">    <span class="keyword">return</span> chardet.detect(self.content)[<span class="string">'encoding'</span>]</span><br></pre></td></tr></table></figure><p>如何修复这个问题呢？先来看一下示例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; r = requests.get(<span class="string">'http://cn.python-requests.org/en/latest/'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; r.headers[<span class="string">'content-type'</span>]</span><br><span class="line"><span class="string">'text/html'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; r.encoding</span><br><span class="line"><span class="string">'ISO-8859-1'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; r.apparent_encoding</span><br><span class="line"><span class="string">'utf-8'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; requests.utils.get_encodings_from_content(r.content)</span><br><span class="line">[<span class="string">'utf-8'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; r = requests.get(<span class="string">'http://reader.360duzhe.com/2013_24/index.html'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; r.headers[<span class="string">'content-type'</span>]</span><br><span class="line"><span class="string">'text/html'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; r.encoding</span><br><span class="line"><span class="string">'ISO-8859-1'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; r.apparent_encoding</span><br><span class="line"><span class="string">'gb2312'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; requests.utils.get_encodings_from_content(r.content)</span><br><span class="line">[<span class="string">'gb2312'</span>]</span><br></pre></td></tr></table></figure><p>通过了解，可以这么用一个monkey patch解决这个问题：</p><pre><code class="python"><span class="keyword">import</span> requests
<span class="function"><span class="keyword">def</span> <span class="title">monkey_patch</span><span class="params">()</span>:</span>
    prop = requests.models.Response.content
    <span class="function"><span class="keyword">def</span> <span class="title">content</span><span class="params">(self)</span>:</span>
        _content = prop.fget(self)
        <span class="keyword">if</span> self.encoding == <span class="string">'ISO-8859-1'</span>:
            encodings = requests.utils.get_encodings_from_content(_content)
            <span class="keyword">if</span> encodings:
                self.encoding = encodings[<span class="number">0</span>]
            <span class="keyword">else</span>:
                self.encoding = self.apparent_encoding
            _content = _content.decode(self.encoding, <span class="string">'replace'</span>).encode(<span class="string">'utf8'</span>, <span class="string">'replace'</span>)
            self._content = _content
        <span class="keyword">return</span> _content
    requests.models.Response.content = property(content)
monkey_patch()
</code></pre><p>原文：<a href="http://liguangming.com/python-requests-ge-encoding-from-headers" target="_blank" rel="noopener">http://liguangming.com/python-requests-ge-encoding-from-headers</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.love4026.org/313891/哥德尔不完备定理/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ray Chang"><meta itemprop="description" content="Think Difficulty"><meta itemprop="image" content="/logo.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Ray's Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/313891/哥德尔不完备定理/" itemprop="url">哥德尔不完备定理</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-08-03T21:26:22+08:00">2014-08-03</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/个人日志/" itemprop="url" rel="index"><span itemprop="name">个人日志</span></a></span></span> <span class="post-meta-divider">|</span><span class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">525</span></span></div></header><div class="post-body" itemprop="articleBody"><p>今天看完了 bbc的纪录片 《数学的故事》，非常有意思，虽然无法理解其中的很多数学知识，但看过之后，你真的会觉得数学是一切知识的基础，包括我们现代社会所用到的一切科技都与他有关系。包括我们的互联网，都是构建在数学大夏之下。</p><p>而其中最有意思的就是“不完备定理”， 纪录片中说的是，总是存在数字的真命题，但你无法证明它有真假。 它举了一个例子，比如一个题目： “引命题无法证明 ”。 如果这命题是假的，这个命题是可证明的，也就意味着它是真命题，这就产生了矛盾。那也就是说，这个命题肯定是真的。这是一个真命题，但你却无法证明。</p><p>哥德尔之后也受精神分裂的困扰，这样的数学，我是无法理解的，至少我只是按自己的想法去理解，让我有点觉得上帝是存在的，这个命题是不是也是无法证明的。</p><p>另外，里面提到的数学都是人类在生活实际中产生的，才知道我们从小所学的数学都是人类几千年来因为使用才产生的，每个数学在早期产生都是有现实意义的，无穷数最开始从印度产生与印度的社会及虚无有关系的，里面讲到了无穷的概念，虚数，以及拓扑，看过之后，你会对数学有更深的认识。</p><p>数学还是非常有意思的。</p><p><a href="http://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E4%B8%8D%E5%AE%8C%E5%A4%87%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">http://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E4%B8%8D%E5%AE%8C%E5%A4%87%E5%AE%9A%E7%90%86</a><br><a href="http://zh.wikipedia.org/wiki/%E5%BA%9E%E5%8A%A0%E8%8E%B1%E7%8C%9C%E6%83%B3%20" target="_blank" rel="noopener">http://zh.wikipedia.org/wiki/%E5%BA%9E%E5%8A%A0%E8%8E%B1%E7%8C%9C%E6%83%B3</a><br><a href="http://zh.wikipedia.org/wiki/%E6%A0%BC%E5%A5%A5%E5%B0%94%E6%A0%BC%C2%B7%E5%BA%B7%E6%89%98%E5%B0%94" target="_blank" rel="noopener">http://zh.wikipedia.org/wiki/%E6%A0%BC%E5%A5%A5%E5%B0%94%E6%A0%BC%C2%B7%E5%BA%B7%E6%89%98%E5%B0%94</a><br><a href="http://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E4%BC%AF%E7%89%B9%E7%9A%8423%E4%B8%AA%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">http://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E4%BC%AF%E7%89%B9%E7%9A%8423%E4%B8%AA%E9%97%AE%E9%A2%98</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.love4026.org/313888/百度离职员工总结：如何做个好员工？/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ray Chang"><meta itemprop="description" content="Think Difficulty"><meta itemprop="image" content="/logo.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Ray's Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/313888/百度离职员工总结：如何做个好员工？/" itemprop="url">百度离职员工总结：如何做个好员工？</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-07-23T09:15:52+08:00">2014-07-23</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/转载/" itemprop="url" rel="index"><span itemprop="name">转载</span></a></span></span> <span class="post-meta-divider">|</span><span class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">4,492</span></span></div></header><div class="post-body" itemprop="articleBody"><p>2014年7月4日，我从百度离职了。</p><p>这是第一次，我不是因为和老板闹翻而离职；</p><p>这是第一次，我带着晋升的喜悦而离职；</p><p>这是第一次，我带着满满的收获而离职。</p><p>我曾经认为，我永远不会成为一个好员工，因为我太独、太挑剔、不喜欢听话的好孩子、而且讨厌一切想要改变我的人。但是三年过去，我改变了不少，我必须承认，所谓“进步”的过程，就是被认可的过程，也是被“驯化”的过程。</p><p>所谓“驯化”，就是了解规则、遵守规则、利用规则的过程。我并非被某些人“驯化”，而是被社会与职场的规律驯化。我曾经鄙视这个过程，但今天看来，作为一个资质平庸的人，如果你想在这个社会里做成点儿什么，“被驯化”是不可避免的。</p><p>我也曾自诩“卓尔不群”，又受了老罗“彪悍的人生不需要解释”的“蛊惑”。但在现实中，这个路子不一定行得通。你不得不向很多人解释、用他们（而不是自己）喜欢的方式解释，因为只有得到他们的认可和支持，你才能继续工作下去。如果你是一个资质平庸的人，你不得不这样做，美剧《犯罪心理》中有一句话：“凡按自己的方式追求理想者，无不树敌。”</p><p>树敌多了，你就死了。</p><p>现在，我不敢说自己是个“好员工”，我只是觉得我是个比曾经的自己更好的员工。在离职的时候，我打算把自己这几年的职场心得总结一下，算是给自己的一个礼物。</p><p>我是一个资质平庸的人，以下这些心得只适用于愚钝且资质平庸的我，对于才华横溢的天才们并不适用。</p><h3 id="一、你有“同理心”吗？"><a href="#一、你有“同理心”吗？" class="headerlink" title="一、你有“同理心”吗？"></a>一、你有“同理心”吗？</h3><p>什么叫“同理心”？</p><p>说复杂点儿，同理心就是站在当事人的角度和位置上，客观地理解当事人的内心感受，且把这种理解传达给当事人的一种沟通交流方式。</p><p>说简单点儿，同理心就是“己所不欲，勿施于人”。将心比心，也就是设身处地去感受、去体谅他人。</p><p>说白了，同理心就是“情商”。</p><p>具体点说：</p><p>同理心就是，领导交办一项工作，你要读懂他的目的、看清他的用意。我经常遇到这样的情况：给团队成员安排工作时，一再询问“我说明白了吗”“有没有问题”，再三确认后，提交上来的东西仍然答非所问。所以我在接受任务时，总会向领导确认：你想要的是什么？你的目的是什么？了解这个以后，就可以站在他的角度，有效的帮他解决问题。</p><p>同理心就是，在激励员工时，点准他们的“兴奋点”，不揭“伤疤”。每个人都有认真工作的理由，家庭富裕的为了证明自己的能力，家境贫寒的为了改善自己的生活，吊儿郎当的爱面子怕丢工作。了解不同人的不同心理需求，才能调动大家的积极性。若是不问青红皂白，拿着鞭子大喊加油，只能是徒劳无功。</p><p>同理心就是，在与他人合作时，了解对方的需求和心理，潜移默化的说服对方，双方为了同一个目标而努力。想用强势压服别人，通常不好使。</p><h3 id="二、听话，出活；"><a href="#二、听话，出活；" class="headerlink" title="二、听话，出活；"></a>二、听话，出活；</h3><p>7年前，我和北京交通台的潘久阳聊天，他说“什么叫好员工啊，好员工特简单，就四个字：听话、出活”。这话我一直记着，这是至理名言。</p><p>什么叫“听话”？有句老话叫“干活不由东，累死也无功”，谁是“东”啊？你的直属领导就是“东”，大部分时候，听他的话准没错儿。</p><p>有朋友说：我有能力，我比领导水平高，我就不听领导的！咱先不说到底谁水平高——既然他能当你领导，肯定有比你强的地方——咱就说水平和能力这事儿，什么叫“有能力”啊？领导用你，你就有能力。不用你，甭管您有再大的能力，都是白费。</p><p>根据我的经验，一般来说，领导都比你水平高，起码在一点上是这样：他比你信息更全面、判断的更准确。因为领导更容易接触到更高层，更了解更高层的意图，他知道的你不知道，你在自己的角度上认为“这么做对”，但领导在更高的层面，并不一定这么看。</p><p>还有朋友说我领导就是瞎指挥，明摆着不对，我干嘛要听他的？这是另外一个问题，咱们最后一条会谈到，如果你觉得现在的环境无法进步，就可以考虑离职了。</p><p>什么叫“出活”？就是领导给你的工作，你得按时完成并且汇报总结。如果这个工作要持续较长时间，那么你需要阶段性的给领导反馈。我们经常犯一个错误，领导安排的工作，他不问你也不说，黑不提白不提这事儿就算过去了。</p><p>过去了？哪儿那么容易啊！领导都记着呢，你等他问你的时候——“诶小陈，上次安排你做的那事儿怎么样了？”——他就已经在心里给你写上了标签：“不靠谱”。</p><p>一个“不靠谱”需要用十个“靠谱”来扭转，两个“不靠谱”就很难转变印象，三个“不靠谱”你就没有机会了。</p><p>“出活”还有一层含义，就是“超预期”。这个咱们在下一点聊。</p><h3 id="三、要想人前显贵，必须背地里受罪；"><a href="#三、要想人前显贵，必须背地里受罪；" class="headerlink" title="三、要想人前显贵，必须背地里受罪；"></a>三、要想人前显贵，必须背地里受罪；</h3><p>在公司里上班，大家的智商都差不多，谁也不比谁强多少，拼的都是努力和用心的程度。你下功夫了，就比别人做得好。哦，本来就不比别人聪明，别人下班你也下班、别人玩儿你也玩儿、别人搞对象你也泡马子，你凭什么比别人干得好？</p><p>“要想人前显贵，必须背地里受罪”的道理并不难懂。就是真到受苦的时候就含糊了，有的人会说，我年纪轻轻的为什么不好好享受生活啊？这种想法很普遍，这本是一个价值观的问题，没什么可说的，一个人想怎么生活都对。但是有一些朋友是在追求理想和享受生活中纠结的，和这些朋友，是可以聊的。</p><p>马云曾经说过：我们追求的应是人生的大平衡，而不是一时一日的小平衡（大意如此）。新东方也有一句话说：怕吃苦吃苦一辈子，不怕苦吃苦半辈子。两句话大意相同，值得深思。</p><p>一件工作，你用心想了做了，领导一看就知道，你想糊弄，也是一看就知道，这个没侥幸。领导在判断这个问题的时候，标准很简单：我想到的，你都没想到，肯定没用心；我想到的，你想到了一部分，用心不够；我没想到的，你想到了，这是用心了——这就是“超预期”。如果你每次都能给你的老板一个超预期的结果，那你无疑就是一个好员工。</p><h3 id="四、能忍多大事儿，就能成多大事儿；"><a href="#四、能忍多大事儿，就能成多大事儿；" class="headerlink" title="四、能忍多大事儿，就能成多大事儿；"></a>四、能忍多大事儿，就能成多大事儿；</h3><p>讲一个笑话：</p><p>在电梯里，领导放了个屁，回头问秘书，谁放的？秘书忙答道：“不是我！”领导不说话，这事儿过去了。不久，秘书被调离，领导在谈起调离原因时说道：“屁大的委屈都受不了，还能做的了啥？”</p><p>在工作上想受到领导的赏识和重用，除了要有过硬的工作能力外，更重要的，要有足够的涵养（抗压力或者回血能力）。能受多大委屈，才能成多大事儿，这是一定的。为了考察你的“抗压力”，领导有时会故意试你，你可一定要经得住考验。</p><p>我自己也经历过类似的事情：</p><p>有一天加班，晚上2点钟到家，收到老板的一封邮件，批评我工作不到位。我收到邮件后就很崩溃，还很委屈。于是当即奋笔疾书，回邮件！解释我是如何工作的，我做的如何有道理，我做的如何有效果……写了2000多字。</p><p>写完了，我好像冷静了一些，我就琢磨一个事儿：如果我是老板，我对一个员工工作不满意，于是我给他写了封邮件批评他，我想看到的是他洋洋洒洒的解释和辩解吗？显然不是啊。然后我就突然明白了，于是我把那2000多字都删了，简单回复了一句话，大意是：我会反思工作的问题，然后尽快整改。</p><p>两个月后我晋升了。在我的晋升仪式上，我对我老板说起这件事，他对我说，我知道你很委屈，我就是想看看你在面对委屈和压力时，会有怎样的反应，这体现了一个人的成熟程度。</p><p>多说一句，人们会感叹“钱难赚，屎难吃”，人人都想“站着把钱赚了”，我更相信他跪着的时候你没看见。我们总是强调“尊严”，比尔盖茨说过一句话：“没有人会在乎你的尊严,你只能在自我感觉良好之前取得尽可能多成就。”</p><p>对于比尔盖茨这样的天才姑且如此，况且我这样资质平庸的碌碌之辈呢？</p><h3 id="五、总躲着领导，你就危险了；"><a href="#五、总躲着领导，你就危险了；" class="headerlink" title="五、总躲着领导，你就危险了；"></a>五、总躲着领导，你就危险了；</h3><p>不少人躲着领导，尽量少跟领导说话、绕着领导走。因为跟领导近了事儿就多，不跟领导多接触，事儿少，多清闲。这是“一叶障目，不见泰山”。</p><p>如果你想在工作上取得一些成绩，我建议还是应该主动的多和领导沟通。领导在平时开会时说的多是大面儿上的话，真话、有用的话、有价值的话不一定说。这并不是他不想说，而是没机会说。</p><p>有心的员工会随时抽时间和领导沟通、增加私人交流的机会：一起吃饭、一起抽烟、一起上下班、甚至一起打球K歌……通过这样的机会，你可以了解领导对于你的看法、对于工作的观点，这些都有益于你调整自己的工作的方式。</p><p>有朋友担心这样做会引起领导反感，其实完全不会，领导们多是孤独的，如果他发现有一个员工虚心向他请教、积极分享工作的思考，他是非常高兴的。</p><p>有朋友说，我不想那么累，我就想混混日子。即便是这样，你最好也主动和领导沟通、主动汇报。你追着他，你是主动的一方，其实你不累；等到他追你的时候，你就被动了，最终就累死了。</p><p>老罗曾经讲过一个故事，说你进入单位，见到老板就低头过去、不理他，他当然也不理你。等到年终考核、或者裁员的时候，老板隐约记得有你这么个人，但不知道你的名字、更不知道你做了什么。老板会想：这是你的错，不是我的错。不开除你开除谁？</p><p>老板也是人，大家用人类的方式沟通，一切会变得简单很多。</p><h3 id="六、帮助别人千万别吝啬；"><a href="#六、帮助别人千万别吝啬；" class="headerlink" title="六、帮助别人千万别吝啬；"></a>六、帮助别人千万别吝啬；</h3><p>马云曾经说，成功就是成就自己帮助别人。这话没错。</p><p>如果你在一家公司工作，你发现你的工作不用任何人协助就能自己独立完成，那你多半是个打杂的。相反，你的工作需要越多人协作，就越复杂、越高级。在实际工作中我发现，我处在一个协作关系网中，如果没有别人的帮助，我就无法工作下去。</p><p>当你正在忙于某项工作时，有同事来向你“求助”，很多时候我们会很直接、甚至粗暴的拒绝，殊不知这样做正在给你今后的工作种下麻烦的种子。风水轮流转，在一家公司里，大家的工作互相交叉的几率很大，说不定你会用上谁，这些人脉关系需要平时去维护。今天你帮助了人家，说不定明天对方就会成为你的救命稻草，这非常可能。</p><p>有一天我正在疲于应付一个项目总结，这时有个其他部门的同事来找我聊合作的事儿，我并不认识他，我耐心的和他介绍了情况，并且真的形成了几次愉快的合作，半年后，我的晋升答辩会上，我发现他是我的答辩委员……</p><h3 id="七、目标再目标，量化再量化；"><a href="#七、目标再目标，量化再量化；" class="headerlink" title="七、目标再目标，量化再量化；"></a>七、目标再目标，量化再量化；</h3><p>没有目标的，都不叫工作；没有量化的，都不叫目标。</p><p>在接受一项工作时，先问目标是什么；在布置一项工作时，先交代目标是什么。这个不说清楚，都是扯淡。</p><p>不想成为蒙着眼睛拉磨的驴？那么除了清楚的知道自己的目标外，还得知道你的部门、你的公司的目标，最关键的，你需要知道，你的工作在总体目标中处在什么地位、扮演什么角色。如果你发现，你工作的目标和总体目标关系很小、甚至没有关系，那么你就很容易被拿掉。</p><p>辞退员工，或给员工绩效打分“不合格”是很令人头疼的，但其实这事儿并不难。关键就在于事先和每个员工一起制定量化的工作目标，并且随时提醒员工，他的工作是否达到了要求。没有达到量化指标，辞退或“不合格”是令所当然事儿，在数据面前，再矫情的人也无话可说。相反，如果谈感觉、聊希望，这事儿就没法办了。</p><h3 id="八、找到解决问题的办法是我的义务；"><a href="#八、找到解决问题的办法是我的义务；" class="headerlink" title="八、找到解决问题的办法是我的义务；"></a>八、找到解决问题的办法是我的义务；</h3><p>领导安排的工作，不能说“我做不了”、“我做不到”。</p><p>公司请我们来工作，是为了解决问题的，如果不能解决问题，我们就没有价值。工作推进中遇到困难，无法继续进行，这是很正常的事儿，我们需要做的是主动寻找答案和办法，哪怕你的办法不妥，那么就去问，但无论如何不能对你的领导说，我不会。</p><p>前天，我在公司里听见隔壁团队的领导安排同事定一个会议室，有公司工作经验的人都知道，会议室是很难订到的，弄不好还需要“托关系，走后门”。这个小同学可能是没有订到，于是和他的领导说“我没订到”，他的领导直接就急了，说：“那怎么办？需要我来订吗？”</p><p>这位领导发火是有道理的，这位小同学在发现自己订不到会议室后，应该做的是自己想办法解决问题——最简单的就是向老同事咨询。</p><p>解决问题的能力是员工最关键的能力，没有之一。在工作中遇到困难特别正常，在这时，我们有一项义务，就是找到解决问题的办法。</p><h3 id="九、尽量不说“不是我，我没有”；"><a href="#九、尽量不说“不是我，我没有”；" class="headerlink" title="九、尽量不说“不是我，我没有”；"></a>九、尽量不说“不是我，我没有”；</h3><p>绝大多数人在面对批评的时候，本能反应都是推卸责任，此时的口头禅就是“不是我”、“没有我”。我总觉得，很多时候，越成熟的人，就越少用本能反应面对问题，因为他们有更强的自控力。</p><p>尽量不说“不是我”、“没有我”这样的话，因为这些话毫无作用，领导听惯了这样的推卸之词，丝毫不会为之所动。此时如果能够主动承担责任，反而体现了一种担</p><p>当。即便真是被冤枉了，当场辩解往往也不是最明智的选择，可以先保持沉默，私下找机会和领导进行沟通。这个详见第三条。</p><h3 id="十、“言多必失”死得惨；"><a href="#十、“言多必失”死得惨；" class="headerlink" title="十、“言多必失”死得惨；"></a>十、“言多必失”死得惨；</h3><p>在公司里，少说闲话，不说是非话，不做是非人。</p><p>你就相信一点：你说的每句话，你的老板都会知道。好话可能不一定，坏话则是一定的。</p><p>还是做个正直的人吧，这样最简单，也受益最大。正直人的原则是：批评当面说，赞美背后讲。</p><h3 id="十一、知道什么时候离开。"><a href="#十一、知道什么时候离开。" class="headerlink" title="十一、知道什么时候离开。"></a>十一、知道什么时候离开。</h3><p>好多同事和朋友和我聊过离职的话题，我对朋友们的建议是，如果你因为觉得工作不爽，那就别离职，因为甭管到哪里，都会不爽：老板不喜欢、同事不可爱、工作太劳累、关系太复杂……我以我在多家大公司工作的经历担保：几乎所有我工作过的公司，令人不爽的事儿都是一样的。</p><p>那么什么时候离开呢？我想，有两种情况：</p><p>1、在这家公司，你已经没有上升的空间、无法学习到更多的东西了；</p><p>2、在这家公司，你已学到足够的知识，可以在新领域或新平台上一展身手了。</p><p>（完）</p><p>原文：<a href="http://meroa.com/baidu-staff-summary/" target="_blank" rel="noopener">http://meroa.com/baidu-staff-summary/</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.love4026.org/313885/linode-vps-使用sendmail发送邮件/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ray Chang"><meta itemprop="description" content="Think Difficulty"><meta itemprop="image" content="/logo.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Ray's Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/313885/linode-vps-使用sendmail发送邮件/" itemprop="url">linode vps 使用sendmail发送邮件</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-07-04T09:46:44+08:00">2014-07-04</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span></span> <span class="post-meta-divider">|</span><span class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">194</span></span></div></header><div class="post-body" itemprop="articleBody"><p>安装sendmail并启动它</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install sendmail</span><br><span class="line">service sendmail start</span><br></pre></td></tr></table></figure><p>设置sendmail开机自动运行</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install chkconfig</span><br><span class="line">chkconfig sendmail <span class="keyword">on</span></span><br></pre></td></tr></table></figure><p>测试邮件发送功能</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">echo</span> <span class="string">"This is test mail"</span> | mail -s <span class="string">'Test mail'</span> xxxxx<span class="variable">@qq</span>.com</span><br></pre></td></tr></table></figure><p>如果提示 mail: command not found， 那么就是没有安装mail命令，此时需要安装mail命令：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> mailx -y</span><br></pre></td></tr></table></figure><p>安装过mail后就可以发送了，我测试了下，发送到我的QQ邮箱中是没有问题，并且不会识别为垃圾邮件。</p><p>如果想配置php的mail发送函数，按以下设置：</p><p>修改下php.ini的配置，调用sendmail功能</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim <span class="regexp">/usr/</span>local<span class="regexp">/php/</span>etc<span class="regexp">/php.ini</span></span><br></pre></td></tr></table></figure><p>找到有关sendmail_path的那一行，去掉行首注释，并改成如下的样子：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sendmail_path</span> = /usr/sbin/sendmail -t -i</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.love4026.org/313867/lnmpa服务器下免费搭建https网站/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ray Chang"><meta itemprop="description" content="Think Difficulty"><meta itemprop="image" content="/logo.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Ray's Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/313867/lnmpa服务器下免费搭建https网站/" itemprop="url">lnmpa服务器下免费搭建https网站</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-06-24T14:22:47+08:00">2014-06-24</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span></span> <span class="post-meta-divider">|</span><span class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">2,027</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img src="/wp-content/uploads/2014/06/20140624143525.jpg" alt="20140624143525"><br>本文讲述如何免费申请SSL证书，并搭建https网站，由于服务器是NGINX，顺便会介绍如何安装SPDY协议。</p><h2 id="StartSSL介绍"><a href="#StartSSL介绍" class="headerlink" title="StartSSL介绍"></a>StartSSL介绍</h2><p><a href="http://www.startssl.com" target="_blank" rel="noopener">StartSSL</a>是一家CA机构，它的根证书很久之前就被一些具有开源背景的浏览器支持（Firefox浏览器、谷歌Chrome浏览器、苹果Safari浏览器等）。<br>在今年9月份，StartSSL竟然搞定了微软：微软在升级补丁中，更新了通过Windows根证书认证程序（Windows Root Certificate Program）的厂商清单，并首次将StartCom公司列入了该认证清单，这是微软首次将提供免费数字验证技术的厂商加入根证书认证列表中。现在，在Windows 7或安装了升级补丁的Windows Vista或Windows XP操作系统中，系统会完全信任由StartCom这类免费数字认证机构认证的数字证书，从而使StartSSL也得到了IE浏览器的支持。</p><h3 id="StartSSL申请注意事项"><a href="#StartSSL申请注意事项" class="headerlink" title="StartSSL申请注意事项"></a>StartSSL申请注意事项</h3><p>（1）需要一个域名，并开通域名邮箱，邮箱前缀为：webmaster这样的信息，一定要开通一个<a href="mailto:webmaster@yourdomainname.com" target="_blank" rel="noopener">webmaster@yourdomainname.com</a>这样的域名，这个会用来验证你的域名；<br>（2）申请时一定要填写完整正确的信息，否则无法通过申请，我就是因为第一次填写的地址信息不全，没有通过，一般添写正确的地址很快就会通过的；<br>（3）打开网站 在control panel / sign-up 注意填写正确资料。收到邮件后复制验证码。然后可以生成一个证书，注意，startssl.com不是以用户名、密码来验证用户的，是用证书来验证用户的。所以生成证书后(火狐会导入证书)，注意备份证书。丢失证书后只能重新注册。<br>（4）登录后还要验证域名才能为该域名生成SSL证书，可以选择在whois里的邮箱、hostmaster@domain、postmaster@domain或者webmaster@domain<br>（5）然后就可以在Certificates wizard里就可以申请SSL证书了。<br>（6）有效期一年（到期前会收到邮件通知续期）。</p><h2 id="申请流程"><a href="#申请流程" class="headerlink" title="申请流程"></a>申请流程</h2><p>所有的资料都最好使用正确的。因为注册SSL是一件很严肃的事情。还有就是如果你的IP地址是在大陆，你输入香港也是会被拒绝的。而且你的地址也是也是要详细的。按照表单写完以后点击Continue按钮。然后你填写的邮箱会收到一个验证码。 上面说大概需要等6个小时收到通知，其实一般一两分钟就会出结果</p><p>打开你的邮箱，把验证码输入到你的浏览器Code的框里，然后继续。</p><p>通过后，会收到通过验证的邮件，然后给你一个URL，输入到浏览器中进行下一步安装证书。如果弹出的窗口依然还让你输入Code，那则输入邮件下面链接的Code。</p><p>点击Continue，接下来你的浏览器开始安装私钥，相当于建立用户名密码</p><p>然后密钥安装成功以后提示你开始安装证书。</p><p>证书安装完毕以后会祝贺你一下。点击完成。 这时给你会收到邮件说你安装好啦，可以使用了。</p><p>在Validations Wizard选择里验证你的域名。按照提示操作就行了，它会扫描你的网站上的邮箱，然后列出来，会给你的邮箱发一封信，所以你一定要有一个企业邮箱来收信的。域名验证成功后，接下来申请域名SSL证书。</p><p>点击Certificates Wizard ，选择下拉菜单中的Web Server SSL/TSL Certificate</p><p>然后进入下一步他会问你验证方式，这一步如果你跳过需要在VPS上设置，具体可以见网站：<a href="http://blog.nicky1605.com/the-free-ssl-configuration-startssl-on-nginx.html" target="_blank" rel="noopener">http://blog.nicky1605.com/the-free-ssl-configuration-startssl-on-nginx.html</a></p><p>如果没有跳过，你必须设置密码，不少于10位的。然后点击下一步生成一段字符串</p><p>这一小的操作中会出现两段字条串，一段类似这样的</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-----<span class="keyword">BEGIN</span> RSA <span class="keyword">PRIVATE</span> KEY-----</span><br><span class="line">Proc-<span class="keyword">Type</span>: <span class="number">4</span>,ENCRYPTED</span><br><span class="line">DEK-Info: AES-<span class="number">256</span>-CBC,<span class="number">1</span>FBB7A12C5332861D52FEDFA2E3E7AE3</span><br><span class="line"></span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>复制内容保存为 <code>/etc/ssl/certs/xxxx.crt</code><br>一段类似这样的</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">----<span class="keyword">BEGIN</span> CERTIFICATE-----</span></span><br><span class="line"><span class="ruby">MIIGdTCCBV2gAwIBAgIDYTrWMA0GCSqGSIc3FQEBBQUAMIGMMQswCQYDVQQGEwJJ</span></span><br><span class="line"><span class="ruby">...</span></span><br></pre></td></tr></table></figure><p>复制内容保存为 <code>/etc/ssl/certs/xxxx.key</code></p><p>下面就是配置你的VPS上的NGINX服务器了。</p><p><code>vi /usr/local/nginx/conf/vhost/xxxx.conf</code></p><p>在Server里添加</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">listen <span class="number">443</span> ssl spdy;</span><br><span class="line">ssl                     on;</span><br><span class="line">ssl_certificate         <span class="regexp">/etc/</span>ssl<span class="regexp">/certs/</span>xxxx.crt;</span><br><span class="line">ssl_certificate_key     <span class="regexp">/etc/</span>ssl<span class="regexp">/certs/</span>xxxx.key;</span><br><span class="line">ssl_session_timeout     <span class="number">10</span>m;</span><br><span class="line">ssl_protocols           SSLv2 SSLv3 TLSv1;</span><br><span class="line">ssl_ciphers             <span class="string">ALL:</span>!<span class="string">ADH:</span>!<span class="string">EXPORT56:</span>RC4+<span class="string">RSA:</span>+<span class="string">HIGH:</span>+<span class="string">MEDIUM:</span>+<span class="string">LOW:</span>+<span class="string">SSLv2:</span>+EXP;</span><br><span class="line">ssl_prefer_server_ciphers       on;</span><br></pre></td></tr></table></figure><p>如果你想让http跳转到https下，需要再加一段代码</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">if</span> (<span class="variable">$ssl_protocol</span> = <span class="string">""</span>) &#123;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)$</span> https://www.domain.com/<span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果出现循环重定向，检查下你的网站根目录下，是否有<code>.htaccess</code>文件，因为我的服务器是lnmpa的，apache的重定向文件还是会起作用的，检查下有无重定向到http的，一般是301重定向需要修改下。</p><p>上面这些做完之后，还需要另外对firefox浏览器作一些配置更改<br>到<code>/etc/ssl/certs/xxxx.crt</code>所在目录执行以下代码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//cert.startssl.com/certs/sub.class1.server.ca.pem</span></span><br><span class="line">cat ca<span class="selector-class">.pem</span> sub<span class="selector-class">.class1</span><span class="selector-class">.server</span><span class="selector-class">.ca</span><span class="selector-class">.pem</span> &gt;&gt; xxxx.crt</span><br></pre></td></tr></table></figure><p>就是向 xxx.crt里面追加一些内容，这样firefox就不会提示证书不安全了。</p><p>下就是重启你的nginx服务器，但这里会提示你需要输入Enter PEM pass phrase<br>总不能每次重启都要输入那个密码吧，这个可以跳过的，方法按照我之前的一篇文章操作</p><p><a href="/313864/lnmp%e4%b8%8bnginx%e9%85%8d%e7%bd%aessl%e5%ae%89%e5%85%a8%e8%af%81%e4%b9%a6%e9%81%bf%e5%85%8d%e5%90%af%e5%8a%a8%e8%be%93%e5%85%a5enter-pem-pass-phrase/" title="LNMP下Nginx配置SSL安全证书避免启动输入Enter PEM pass phrase">/313864/lnmp%E4%B8%8Bnginx%E9%85%8D%E7%BD%AEssl%E5%AE%89%E5%85%A8%E8%AF%81%E4%B9%A6%E9%81%BF%E5%85%8D%E5%90%AF%E5%8A%A8%E8%BE%93%E5%85%A5enter-pem-pass-phrase/</a></p><h3 id="SPDY协议安装"><a href="#SPDY协议安装" class="headerlink" title="SPDY协议安装"></a>SPDY协议安装</h3><p>你要先下载最新的 OpenSSL，比如 1.0.1e，<a href="http://www.openssl.org/source/" target="_blank" rel="noopener">这里</a>是下载列表，红色标注的就是最新版了。因为前些时间的openssl漏洞，现在linode好像自动已经升级到最新版1.0.1e了。</p><p>但还是需要下载，解压</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">wget http:<span class="comment">//www.openssl.org/source/openssl-1.0.1e.tar.gz</span></span><br><span class="line">tar zxvpf openssl-<span class="number">1.0</span>.<span class="number">1</span>e<span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure><p>然后下载最新的<a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">Nginx</a></p><p>先用 /usr/local/nginx/sbin/nginx -V 这个是查看nginx安装了什么模块 安装的时候把这些都再加上</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="string">//nginx.org/download/nginx-1.7.2.tar.gz</span></span><br><span class="line">tar zxvf nginx-1.7.2.tar.gz</span><br><span class="line"><span class="keyword">cd</span> nginx-1.7.2</span><br><span class="line"><span class="string">./configure</span> <span class="params">--user=www</span> <span class="params">--group=www</span> <span class="params">--prefix=/usr/local/nginx</span> <span class="params">--with-http_stub_status_module</span> <span class="params">--with-http_ssl_module</span> <span class="params">--with-http_gzip_static_module</span> <span class="params">--with-ipv6</span> <span class="params">--with-pcre</span> <span class="params">--with-http_sub_module</span> <span class="params">--with-http_spdy_module</span> <span class="params">--with-openssl=/tmp/openssl-1</span>.0.1e</span><br><span class="line">mv <span class="string">/usr/local/nginx/sbin/nginx</span> <span class="string">/usr/local/nginx/sbin/nginx.old</span></span><br><span class="line">cp objs/nginx <span class="string">/usr/local/nginx/sbin/nginx</span></span><br><span class="line"><span class="string">/usr/local/nginx/sbin/nginx</span> -t</span><br><span class="line">make upgrade</span><br><span class="line"><span class="string">/usr/local/nginx/sbin/nginx</span> -v</span><br></pre></td></tr></table></figure><p>上面需要注意的是<code>./configure --with-http_ssl_module --with-http_spdy_module --with-openssl=/tmp/openssl-1.0.1e</code> 这是最小安装方法，你需要根据自己的配置安装，上面是lnmpa下面的。</p><p><code>--with-openssl=/tmp/openssl-1.0.1e</code> 路径就是刚下载的那个路径。</p><p>再配置完成后，执行 <code>/etc/init.d/nginx reload</code> 或 <code>/usr/local/nginx/sbin/nginx -s reload</code> 重载 Nginx 配置文件即可正常访问了。</p><p>如果你不想使用 SPDY ，记得修改Server里的 <code>listen 443 ssl spdy;</code> 改为 <code>listen 443 ssl;</code></p><p><strong>如何查看有没有启用SPDY成功没</strong></p><p>在Chrome浏览器里打开 chrome://net-internals/#spdy 便能查看目前使用SPDY的连接。</p><p>或者使用插件查看， <a href="https://chrome.google.com/webstore/detail/spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin</a></p><p><strong>补充：关于 “此网页包含的脚本来自于身份未经验证的源” 的提示信息</strong></p><p>出现这个一般是因为在网页内容中加载了其它不带https的内容，比如加载了google font,</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link <span class="attribute">href</span>=<span class="string">'http://fonts.googleapis.com/css?family=Antic+Slab'</span> <span class="attribute">rel</span>=<span class="string">'stylesheet'</span> <span class="attribute">type</span>=<span class="string">'text/css'</span>&gt;</span><br></pre></td></tr></table></figure><p>一般解决办法就是把资源下载到本地，然后使用相对路径，或者使用https的资源地址。<br>google 支持https连接，上面的情况你可以直接改为</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link <span class="attribute">href</span>=<span class="string">'https://fonts.googleapis.com/css?family=Antic+Slab'</span> <span class="attribute">rel</span>=<span class="string">'stylesheet'</span> <span class="attribute">type</span>=<span class="string">'text/css'</span>&gt;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.love4026.org/313864/lnmp下nginx配置ssl安全证书避免启动输入enter-pem-pass-phrase/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ray Chang"><meta itemprop="description" content="Think Difficulty"><meta itemprop="image" content="/logo.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Ray's Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/313864/lnmp下nginx配置ssl安全证书避免启动输入enter-pem-pass-phrase/" itemprop="url">lnmp下nginx配置ssl安全证书避免启动输入enter pem pass phrase</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-06-24T10:28:42+08:00">2014-06-24</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span></span> <span class="post-meta-divider">|</span><span class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">233</span></span></div></header><div class="post-body" itemprop="articleBody"><p>从Startssl免费申请到ssh证书后，把自己的一个网站搭建成了https网站。但是由于生成私钥key文件时输入了密码，导致每次重启nginx时都提示Enter PEM pass phrase ， 这样会导致自己VPS上的重启脚本无法自动工作，每次都要人工重启。</p><p>在网上搜索后找到了解决办法。</p><p>在key的目录执行：<code>openssl rsa -in server.key -out server.key.unsecure</code> 然后在配置文件里使用unsecure这个文件名就行了</p><p>修改后的nginx配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里是SSL的相关配置</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">443</span>;</span><br><span class="line">  <span class="attribute">server_name</span> www.example.com; <span class="comment"># 你自己的域名</span></span><br><span class="line">  <span class="attribute">root</span> /home/wwwroot/www.example.com;</span><br><span class="line">  <span class="attribute">ssl</span> <span class="literal">on</span>;</span><br><span class="line">  <span class="attribute">ssl_certificate</span> /etc/ssl/certs/server.crt;</span><br><span class="line">  <span class="comment"># 修改下面这一行指向我们生成的server.key.unsecure文件</span></span><br><span class="line">  <span class="attribute">ssl_certificate_key</span> /etc/ssl/certs/server.key.unsecure;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用<code>/etc/init.d/nginx restart</code>重启Nginx.不提示便表示成功了。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.love4026.org/313862/restful-api-设计最佳实践/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ray Chang"><meta itemprop="description" content="Think Difficulty"><meta itemprop="image" content="/logo.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Ray's Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/313862/restful-api-设计最佳实践/" itemprop="url">restful api 设计最佳实践</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-06-19T16:01:57+08:00">2014-06-19</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/转载/" itemprop="url" rel="index"><span itemprop="name">转载</span></a></span></span> <span class="post-meta-divider">|</span><span class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">5,205</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>目前互联网上充斥着大量的关于RESTful API（为方便，下文中“RESTful API ”简写为“API”）如何设计的文章，然而却没有一个”万能“的设计标准：如何鉴权？API 格式如何？你的API是否应该加入版本信息？当你开始写一个app的时候，特别是后端模型部分已经写完的时候，你不得不殚精竭虑的设计和实现自己app的public API部分。因为一旦发布，对外发布的API将会很难改变。</p><p>在给SupportedFu设计API的时候，我试图以实用的角度来解决上面提到的问题。我希望可以设计出容易使用，容易部署，并且足够灵活的API，本文因此而生。</p><h2 id="API设计的基本要求"><a href="#API设计的基本要求" class="headerlink" title="API设计的基本要求"></a>API设计的基本要求</h2><p>网上的很多关于API设计的观点都十分”学院派“，它们也许更有理论基础，但是有时却和现实世界脱轨（因此我是自由派）。所以我这篇文章的目标是从实践的角度出发，给出当前网络应用的API设计最佳实践（当然，是我认为的最佳了~），如果觉得不合适，我不会遵从标准。当然作为设计的基础，几个必须的原则还是要遵守的：</p><ol><li>当标准合理的时候遵守标准。</li><li>API应该对程序员友好，并且在浏览器地址栏容易输入。</li><li>API应该简单，直观，容易使用的同时优雅。</li><li>API应该具有足够的灵活性来支持上层ui。</li><li>API设计权衡上述几个原则。</li></ol><p>需要强调的是：API的就是程序员的UI，和其他UI一样，你必须仔细考虑它的用户体验！</p><h2 id="使用RESTful-URLs-和action"><a href="#使用RESTful-URLs-和action" class="headerlink" title="使用RESTful URLs 和action."></a>使用RESTful URLs 和action.</h2><p>虽然前面我说没有一个万能的API设计标准。但确实有一个被普遍承认和遵守：RESTfu设计原则。它被Roy Felding提出（在他的”基于网络的软件架构“论文中<a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm" target="_blank" rel="noopener">第五章</a>）。而REST的核心原则是将你的API拆分为逻辑上的资源。这些资源通过http被操作（GET ,POST,PUT,DELETE）。</p><h2 id="那么我应该如何拆分出这些资源呢？"><a href="#那么我应该如何拆分出这些资源呢？" class="headerlink" title="那么我应该如何拆分出这些资源呢？"></a>那么我应该如何拆分出这些资源呢？</h2><p>显然从API用户的角度来看，”资源“应该是个名词。即使你的内部数据模型和资源已经有了很好的对应，API设计的时候你仍然不需要把它们一对一的都暴露出来。这里的关键是隐藏内部资源，暴露必需的外部资源。</p><p>在SupportFu里，资源是 ticket、user、group。</p><p>一旦定义好了要暴露的资源，你可以定义资源上允许的操作，以及这些操作和你的API的对应关系：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*   GET <span class="string">/tickets</span> <span class="comment"># 获取ticket列表</span></span><br><span class="line">*   GET <span class="string">/tickets/12</span> <span class="comment"># 查看某个具体的ticket</span></span><br><span class="line">*   POST <span class="string">/tickets</span> <span class="comment"># 新建一个ticket</span></span><br><span class="line">*   PUT <span class="string">/tickets/12</span> <span class="comment"># 更新ticket 12.</span></span><br><span class="line">*   DELETE <span class="string">/tickets/12</span> <span class="comment">#删除ticekt 12</span></span><br></pre></td></tr></table></figure><p>可以看出使用REST的好处在于可以充分利用http的强大实现对资源的CURD功能。而这里你只需要一个endpoint：/tickets,再没有其他什么命名规则和url规则了，cool！</p><h2 id="这个endpoint的单数复数"><a href="#这个endpoint的单数复数" class="headerlink" title="这个endpoint的单数复数"></a>这个endpoint的单数复数</h2><p>一个可以遵从的规则是：虽然看起来使用复数来描述某一个资源实例看起来别扭，但是统一所有的endpoint，使用复数使得你的URL更加规整。这让API使用者更加容易理解，对开发者来说也更容易实现。</p><p>如何处理关联？关于如何处理资源之间的管理REST原则也有相关的描述：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*   GET /tickets/<span class="number">12</span>/messages- Retrieves list <span class="keyword">of</span> messages <span class="keyword">for</span> ticket <span class="string">#12</span></span><br><span class="line">*   GET /tickets/<span class="number">12</span>/messages/<span class="number">5</span>- Retrieves <span class="keyword">message</span> <span class="string">#5</span> <span class="keyword">for</span> ticket <span class="string">#12</span></span><br><span class="line">*   POST /tickets/<span class="number">12</span>/messages- Creates a new <span class="keyword">message</span> <span class="keyword">in</span> ticket <span class="string">#12</span></span><br><span class="line">*   PUT /tickets/<span class="number">12</span>/messages/<span class="number">5</span>- Updates <span class="keyword">message</span> <span class="string">#5</span> <span class="keyword">for</span> ticket <span class="string">#12</span></span><br><span class="line">*   PATCH /tickets/<span class="number">12</span>/messages/<span class="number">5</span>- Partially updates <span class="keyword">message</span> <span class="string">#5</span> <span class="keyword">for</span> ticket <span class="string">#12</span></span><br><span class="line">*   DELETE /tickets/<span class="number">12</span>/messages/<span class="number">5</span>- Deletes <span class="keyword">message</span> <span class="string">#5</span> <span class="keyword">for</span> ticket <span class="string">#12</span></span><br></pre></td></tr></table></figure><p>其中，如果这种关联和资源独立，那么我们可以在资源的输出表示中保存相应资源的endpoint。然后API的使用者就可以通过点击链接找到相关的资源。如果关联和资源联系紧密。资源的输出表示就应该直接保存相应资源信息。（例如这里如果message资源是独立存在的，那么上面 GET /tickets/12/messages就会返回相应message的链接；相反的如果message不独立存在，他和ticket依附存在，则上面的API调用返回直接返回message信息）</p><h2 id="不符合CURD的操作"><a href="#不符合CURD的操作" class="headerlink" title="不符合CURD的操作"></a>不符合CURD的操作</h2><p>对这个令人困惑的问题，下面是一些解决方法：</p><ol><li>重构你的行为action。当你的行为不需要参数的时候，你可以把active对应到activated这个资源，（更新使用patch）.</li><li>以子资源对待。例如:github上，对一个gists加星操作：PUT /gists/:id/star 并且取消星操作：DELETE /gists/:id/star.</li><li>有时候action实在没有难以和某个资源对应上例如search。那就这么办吧。我认为API的使用者对于/search这种url也不会有太大意见的（毕竟他很容易理解）。只要注意在文档中写清楚就可以了。<br>4.</li></ol><h2 id="永远使用SSL"><a href="#永远使用SSL" class="headerlink" title="永远使用SSL"></a>永远使用SSL</h2><p>毫无例外，永远都要使用SSL。你的应用不知道要被谁，以及什么情况访问。有些是安全的，有些不是。使用SSL可以减少鉴权的成本：你只需要一个简单的令牌（token）就可以鉴权了，而不是每次让用户对每次请求签名。</p><p>值得注意的是：不要让非SSL的url访问重定向到SSL的url。</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>文档和API本身一样重要。文档应该容易找到，并且公开（把它们藏到pdf里面或者存到需要登录的地方都不太好）。文档应该有展示请求和输出的例子：或者以点击链接的方式或者通过curl的方式（请见openstack的文档）。如果有更新（特别是公开的API），应该及时更新文档。文档中应该有关于何时弃用某个API的时间表以及详情。使用邮件列表或者博客记录是好方法。</p><h2 id="版本化"><a href="#版本化" class="headerlink" title="版本化"></a>版本化</h2><p>在API上加入版本信息可以有效的防止用户访问已经更新了的API，同时也能让不同主要版本之间平稳过渡。关于是否将版本信息放入url还是放入请求头有过争论：<a href="http://stackoverflow.com/questions/389169/best-practices-for-API-versioning" target="_blank" rel="noopener">API version should be included in the URL or in a header</a>. 学术界说它应该放到header里面去，但是如果放到url里面我们就可以跨版本的访问资源了。。（参考openstack）。</p><p>strip使用的方法就很好：它的url里面有主版本信息，同时请求头俩面有子版本信息。这样在子版本变化过程中url的稳定的。变化有时是不可避免的，关键是如何管理变化。完整的文档和合理的时间表都会使得API使用者使用的更加轻松。</p><h2 id="结果过滤，排序，搜索："><a href="#结果过滤，排序，搜索：" class="headerlink" title="结果过滤，排序，搜索："></a>结果过滤，排序，搜索：</h2><p>url最好越简短越好，和结果过滤，排序，搜索相关的功能都应该通过参数实现(并且也很容易实现)。</p><p><strong>过滤：</strong>为所有提供过滤功能的接口提供统一的参数。例如：你想限制get /tickets 的返回结果:只返回那些open状态的ticket–get /tickektsstate=open这里的state就是过滤参数。</p><p><strong>排序：</strong>和过滤一样，一个好的排序参数应该能够描述排序规则，而不业务相关。复杂的排序规则应该通过组合实现：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*   GET /ticketssort=-priority- Retrieves <span class="keyword">a</span> list <span class="keyword">of</span> tickets <span class="keyword">in</span> <span class="keyword">descending</span> order <span class="keyword">of</span> priority</span><br><span class="line">*   GET /ticketssort=-priority,created_at- Retrieves <span class="keyword">a</span> list <span class="keyword">of</span> tickets <span class="keyword">in</span> <span class="keyword">descending</span> order <span class="keyword">of</span> priority. Within <span class="keyword">a</span> specific priority, older tickets are ordered <span class="keyword">first</span></span><br></pre></td></tr></table></figure><p>这里第二条查询中，排序规则有多个rule以逗号间隔组合而成。</p><p><strong>搜索：</strong>有些时候简单的排序是不够的。我们可以使用搜索技术（ElasticSearch和Lucene）来实现（依旧可以作为url的参数）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*   GET /ticketsq=<span class="keyword">return</span>&amp;amp;state=<span class="keyword">open</span>&amp;amp;sort=-priority,created_at- Retrieve the highest priority <span class="keyword">open</span> tickets mentioning the word ‘<span class="keyword">return</span>’</span><br></pre></td></tr></table></figure><p>对于经常使用的搜索查询，我们可以为他们设立别名,这样会让API更加优雅。例如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">get</span> /<span class="attribute">ticketsq</span>=recently_closed -&gt; <span class="builtin-name">get</span> /tickets/recently_closed.</span><br></pre></td></tr></table></figure><h2 id="限制API返回值的域"><a href="#限制API返回值的域" class="headerlink" title="限制API返回值的域"></a>限制API返回值的域</h2><p>有时候API使用者不需要所有的结果，在进行横向限制的时候（例如值返回API结果的前十项）还应该可以进行纵向限制。并且这个功能能有效的提高网络带宽使用率和速度。可以使用fields查询参数来限制返回的域例如：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /ticketsfields=id,subject,customer_name,updated_at&amp;amp;<span class="keyword">state</span>=open&amp;amp;sort=-updated_at</span><br></pre></td></tr></table></figure><h2 id="更新和创建操作应该返回资源"><a href="#更新和创建操作应该返回资源" class="headerlink" title="更新和创建操作应该返回资源"></a>更新和创建操作应该返回资源</h2><p>PUT、POST、PATCH 操作在对资源进行操作的时候常常有一些副作用：例如created_at,updated_at 时间戳。为了防止用户多次的API调用（为了进行此次的更新操作），我们应该会返回更新的资源（updated representation.）例如：在POST操作以后，返回201 created 状态码，并且包含一个指向新资源的url作为返回头</p><h2 id="是否需要-“HATEOAS”"><a href="#是否需要-“HATEOAS”" class="headerlink" title="是否需要 “HATEOAS”"></a>是否需要 “HATEOAS”</h2><p>网上关于是否允许用户创建新的url有很大的异议（注意不是创建资源产生的url）。为此REST制定了HATEOAS来描述了和endpoint进行交互的时候，行为应该在资源的metadata返回值里面进行定义。</p><p>（译注：作者这里认为HATEOAS还不算成熟，我也不怎么理解这段就算了，读者感兴趣可以自己去原文查看）</p><h2 id="只提供json作为返回格式"><a href="#只提供json作为返回格式" class="headerlink" title="只提供json作为返回格式"></a>只提供json作为返回格式</h2><p>现在开始比较一下XML和json了。XML即冗长，难以阅读，又不适合各种编程语言解析。当然XML有扩展性的优势，但是如果你只是将它来对内部资源串行化，那么他的扩展优势也发挥不出来。很多应用（youtube,twitter,box）都已经开始抛弃XML了，我也不想多费口舌。给了google上的趋势图吧：</p><p><img src="http://www.vinaysahni.com/images/201305-xml-vs-json-api.png" alt=""></p><p>当然如果的你使用用户里面企业用户居多，那么可能需要支持XML。如果是这样的话你还有另外一个问题：你的http请求中的media类型是应该和accept 头同步还是和url？为了方便（browser explorability）,应该是在url中(用户只要自己拼url就好了)。如果这样的话最好的方法是使用.xml或者.json的后缀。</p><h2 id="命名方式？"><a href="#命名方式？" class="headerlink" title="命名方式？"></a>命名方式？</h2><p>是蛇形命令（下划线和小写）还是驼峰命名？如果使用json那么最好的应该是遵守JAVASCRIPT的命名方法-也就是说骆驼命名法。如果你正在使用多种语言写一个库，那么最好按照那些语言所推荐的，java，c#使用骆驼，python，ruby使用snake。</p><p>个人意见：我总觉得蛇形命令更好使一些，当然这没有什么理论的依据。有人说蛇形命名读起来更快，能达到20%，也不知道真假<a href="http://ieeexplore.ieee.org/xpl/articleDetails.jsptp=&amp;arnumber=5521745" target="_blank" rel="noopener">http://ieeexplore.ieee.org/xpl/articleDetails.jsptp=&amp;arnumber=5521745</a></p><h2 id="默认使用pretty-print格式，使用gzip"><a href="#默认使用pretty-print格式，使用gzip" class="headerlink" title="默认使用pretty print格式，使用gzip"></a>默认使用pretty print格式，使用gzip</h2><p>只是使用空格的返回结果从浏览器上看总是觉得很恶心(一大坨有没有？～)。当然你可以提供url上的参数来控制使用“pretty print”，但是默认开启这个选项还是更加友好。格外的传输上的损失不会太大。相反你如果忘了使用gzip那么传输效率将会大大减少，损失大大增加。想象一个用户正在debug那么默认的输出就是可读的-而不用将结果拷贝到其他什么软件中在格式化-是想起来就很爽的事，不是么？</p><p>下面是一个例子:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl https:<span class="comment">//API.github.com/users/veesahni &gt; with-whitespace.txt</span></span><br><span class="line">$ ruby -r json -e <span class="string">'puts JSON JSON.parse(STDIN.read)'</span> &lt; with-whitespace<span class="selector-class">.txt</span> &gt; without-whitespace.txt</span><br><span class="line">$ gzip -c with-whitespace<span class="selector-class">.txt</span> &gt; with-whitespace<span class="selector-class">.txt</span><span class="selector-class">.gz</span></span><br><span class="line">$ gzip -c without-whitespace<span class="selector-class">.txt</span> &gt; without-whitespace<span class="selector-class">.txt</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*   <span class="keyword">without</span>-whitespace.txt- <span class="number">1252</span> <span class="keyword">bytes</span></span><br><span class="line">*   <span class="keyword">with</span>-whitespace.txt- <span class="number">1369</span> <span class="keyword">bytes</span></span><br><span class="line">*   <span class="keyword">without</span>-whitespace.txt.gz- <span class="number">496</span> <span class="keyword">bytes</span></span><br><span class="line">*   <span class="keyword">with</span>-whitespace.txt.gz- <span class="number">509</span> <span class="keyword">bytes</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，多余的空格使得结果大小多出了8.5%（没有使用gzip），相反只多出了2.6%。据说：twitter使用gzip之后它的streaming API传输减少了80%（link:<a href="https://dev.twitter.com/blog/announcing-gzip-compression-streaming-APIs）" target="_blank" rel="noopener">https://dev.twitter.com/blog/announcing-gzip-compression-streaming-APIs）</a>.</p><h2 id="只在需要的时候使用“envelope”"><a href="#只在需要的时候使用“envelope”" class="headerlink" title="只在需要的时候使用“envelope”"></a>只在需要的时候使用“envelope”</h2><p>很多API象下面这样返回结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"data"</span> : &#123;</span><br><span class="line">    <span class="attr">"id"</span> : <span class="number">123</span>,</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"John"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理由很简单：这样做可以很容易扩展返回结果，你可以加入一些分页信息，一些数据的元信息等－这对于那些不容易访问到返回头的API使用者来说确实有用，但是随着“标准”的发展（cors和<a href="http://tools.ietf.org/html/rfc5988#page-6都开始被加入到标准中了），我个人推荐不要那么做。" target="_blank" rel="noopener">http://tools.ietf.org/html/rfc5988#page-6都开始被加入到标准中了），我个人推荐不要那么做。</a></p><h2 id="何时使用envelope？"><a href="#何时使用envelope？" class="headerlink" title="何时使用envelope？"></a>何时使用envelope？</h2><p>有两种情况是应该使用envelope的。如果API使用者确实无法访问返回头，或者API需要支持交叉域请求（通过jsonp）。</p><p>jsonp请求在请求的url中包含了一个callback函数参数。如果给出了这个参数，那么API应该返回200，并且把真正的状态码放到返回值里面（包装在信封里），例如：<br></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">callback_function</span>(&#123;</span><br><span class="line">  <span class="attribute">status_code</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attribute">next_page</span>: <span class="string">"https://.."</span>,</span><br><span class="line">  <span class="attribute">response</span>: &#123;</span><br><span class="line">    ... actual JSON response body ... </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p>同样为了支持无法方法返回头的API使用者，可以允许envelope=true这样的参数。</p><h2 id="在post-put-patch上使用json作为输入"><a href="#在post-put-patch上使用json作为输入" class="headerlink" title="在post,put,patch上使用json作为输入"></a>在post,put,patch上使用json作为输入</h2><p>如果你认同我上面说的，那么你应该决定使用json作为所有的API输出格式，那么我们接下来考虑考虑API的输入数据格式。</p><p>很多的API使用url编码格式：就像是url查询参数的格式一样：单纯的键值对。这种方法简单有效，但是也有自己的问题：它没有数据类型的概念。这使得程序不得不根据字符串解析出布尔和整数,而且还没有层次结构–虽然有一些关于层次结构信息的约定存在可是和本身就支持层次结构的json比较一下还是不很好用。</p><p>当然如果API本身就很简单，那么使用url格式的输入没什么问题。但对于复杂的API你应该使用json。或者干脆统一使用json。</p><p>注意使用json传输的时候，要求请求头里面加入：Content-Type：application/json.，否则抛出415异常（unsupported media type）。</p><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>分页数据可以放到“信封”里面，但随着标准的改进，现在我推荐将分页信息放到link header里面：<a href="http://tools.ietf.org/html/rfc5988#page-6。" target="_blank" rel="noopener">http://tools.ietf.org/html/rfc5988#page-6。</a></p><p>使用link header的API应该返回一系列组合好了的url而不是让用户自己再去拼。这点在基于游标的分页中尤为重要。例如下面，来自github的文档</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Link:</span> <span class="params">&lt;https://api.github.com/user/repos?page=<span class="number">3</span><span class="variable">&amp;amp</span>;per_page=<span class="number">100</span>&gt;</span>; rel=<span class="string">"next"</span>, </span><br><span class="line"><span class="params">&lt;https://api.github.com/user/repos?page=<span class="number">50</span><span class="variable">&amp;amp</span>;per_page=<span class="number">100</span>&gt;</span>; rel=<span class="string">"last"</span></span><br></pre></td></tr></table></figure><h2 id="自动加载相关的资源"><a href="#自动加载相关的资源" class="headerlink" title="自动加载相关的资源"></a>自动加载相关的资源</h2><p>很多时候，自动加载相关资源非常有用，可以很大的提高效率。但是这却<a href="http://idbentley.com/blog/2013/03/14/should-restful-apis-include-relationships/" target="_blank" rel="noopener">和RESTful的原则相背</a>。为了如此，我们可以在url中添加参数：embed（或者expend）。embed可以是一个逗号分隔的串，例如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /ticket/<span class="attribute">12embed</span>=customer.name,assigned_user</span><br></pre></td></tr></table></figure><p>对应的API返回值如下：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"id"</span> : <span class="number">12</span>,</span><br><span class="line">  <span class="string">"subject"</span> : <span class="string">"I have a question!"</span>,</span><br><span class="line">  <span class="string">"summary"</span> : <span class="string">"Hi, ...."</span>,</span><br><span class="line">  <span class="string">"customer"</span> : &#123;</span><br><span class="line">    <span class="string">"name"</span> : <span class="string">"Bob"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  assigned_user: &#123;</span><br><span class="line">   <span class="string">"id"</span> : <span class="number">42</span>,</span><br><span class="line">   <span class="string">"name"</span> : <span class="string">"Jim"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得提醒的是，这个功能有时候会很复杂，并且可能导致<a href="http://stackoverflow.com/questions/97197/what-is-the-n1-selects-issue" target="_blank" rel="noopener">N+1 SELECT 问题</a>。</p><h2 id="重写HTTP方法"><a href="#重写HTTP方法" class="headerlink" title="重写HTTP方法"></a>重写HTTP方法</h2><p>有的客户端只能发出简单的GET 和POST请求。为了照顾他们，我们可以重写HTTP请求。这里没有什么标准，但是一个普遍的方式是接受X-HTTP-Method-Override请求头。</p><h2 id="速度限制"><a href="#速度限制" class="headerlink" title="速度限制"></a>速度限制</h2><p>为了避免请求泛滥，给API设置速度限制很重要。为此 <a href="http://tools.ietf.org/html/rfc6585" target="_blank" rel="noopener">RFC 6585</a> 引入了HTTP状态码<a href="http://tools.ietf.org/html/rfc6585#section-4" target="_blank" rel="noopener">429（too many requests）</a>。加入速度设置之后，应该提示用户，至于如何提示标准上没有说明，不过流行的方法是使用HTTP的返回头。</p><p>下面是几个必须的返回头（依照twitter的命名规则）：</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*   X-Rate-<span class="keyword">Limit</span>-<span class="keyword">Limit</span> :当前时间段允许的并发请求数</span><br><span class="line">*   X-Rate-<span class="keyword">Limit</span>-Remaining:当前时间段保留的请求数。</span><br><span class="line">*   X-Rate-<span class="keyword">Limit</span>-Reset:当前时间段剩余秒数</span><br></pre></td></tr></table></figure><p><strong>为什么使用当前时间段剩余秒数而不是时间戳？</strong></p><p>时间戳保存的信息很多，但是也包含了很多不必要的信息，用户只需要知道还剩几秒就可以再发请求了这样也避免了<a href="http://en.wikipedia.org/wiki/Clock_skew" target="_blank" rel="noopener">clock skew问题</a>。</p><p>有些API使用UNIX格式时间戳，我建议不要那么干。为什么？HTTP 已经规定了使用 <a href="http://www.ietf.org/rfc/rfc1123.txt" target="_blank" rel="noopener">RFC 1123</a> 时间格式</p><h2 id="鉴权-Authentication"><a href="#鉴权-Authentication" class="headerlink" title="鉴权 Authentication"></a>鉴权 Authentication</h2><p>restful API是无状态的也就是说用户请求的鉴权和cookie以及session无关，每一次请求都应该包含鉴权证明。</p><p>通过使用ssl我们可以不用每次都提供用户名和密码：我们可以给用户返回一个随机产生的token。这样可以极大的方便使用浏览器访问API的用户。这种方法适用于用户可以首先通过一次用户名-密码的验证并得到token，并且可以拷贝返回的token到以后的请求中。如果不方便，可以使用OAuth 2来进行token的安全传输。</p><p>支持jsonp的API需要额外的鉴权方法，因为jsonp请求无法发送普通的credential。这种情况下可以在查询url中添加参数：access_token。注意使用url参数的问题是：目前大部分的网络服务器都会讲query参数保存到服务器日志中，这可能会成为大的安全风险。</p><p>注意上面说到的只是三种传输token的方法，实际传输的token可能是一样的。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>HTTP提供了自带的缓存框架。你需要做的是在返回的时候加入一些返回头信息，在接受输入的时候加入输入验证。基本两种方法：</p><p><strong>ETag：</strong>当生成请求的时候，在HTTP头里面加入ETag，其中包含请求的校验和和哈希值，这个值和在输入变化的时候也应该变化。如果输入的HTTP请求包含IF-NONE-MATCH头以及一个ETag值，那么API应该返回304 not modified状态码，而不是常规的输出结果。</p><p><strong>Last-Modified：</strong>和etag一样，只是多了一个时间戳。返回头里的Last-Modified：包含了 <a href="http://www.ietf.org/rfc/rfc1123.txt" target="_blank" rel="noopener">RFC 1123</a> 时间戳，它和IF-MODIFIED-SINCE一致。HTTP规范里面有三种date格式，服务器应该都能处理。</p><h2 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h2><p>就像html错误页面能够显示错误信息一样，API 也应该能返回可读的错误信息–它应该和一般的资源格式一致。API应该始终返回相应的状态码，以反映服务器或者请求的状态。API的错误码可以分为两部分，400系列和500系列，400系列表明客户端错误：如错误的请求格式等。500系列表示服务器错误。API应该至少将所有的400系列的错误以json形式返回。如果可能500系列的错误也应该如此。json格式的错误应该包含以下信息：一个有用的错误信息，一个唯一的错误码，以及任何可能的详细错误描述。如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"code"</span> : <span class="number">1234</span>,</span><br><span class="line">  <span class="attr">"message"</span> : <span class="string">"Something bad happened :-("</span>,</span><br><span class="line">  <span class="attr">"description"</span> : <span class="string">"More details about the error here"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对PUT,POST,PATCH的输入的校验也应该返回相应的错误信息，例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"code"</span> : <span class="number">1024</span>,</span><br><span class="line">  <span class="attr">"message"</span> : <span class="string">"Validation Failed"</span>,</span><br><span class="line">  <span class="attr">"errors"</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"code"</span> : <span class="number">5432</span>,</span><br><span class="line">      <span class="attr">"field"</span> : <span class="string">"first_name"</span>,</span><br><span class="line">      <span class="attr">"message"</span> : <span class="string">"First name cannot have fancy characters"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="attr">"code"</span> : <span class="number">5622</span>,</span><br><span class="line">       <span class="attr">"field"</span> : <span class="string">"password"</span>,</span><br><span class="line">       <span class="attr">"message"</span> : <span class="string">"Password cannot be blank"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">200 </span>ok  - 成功返回状态，对应，<span class="keyword">GET</span>,<span class="keyword">PUT</span>,PATCH,<span class="keyword">DELETE</span>.</span><br><span class="line"><span class="symbol">201 </span>created  - 成功创建。</span><br><span class="line"><span class="symbol">304 </span><span class="keyword">not</span> modified   - HTTP缓存有效。</span><br><span class="line"><span class="symbol">400 </span>bad request   - 请求格式错误。</span><br><span class="line"><span class="symbol">401 </span>unauthorized   - 未授权。</span><br><span class="line"><span class="symbol">403 </span>forbidden   - 鉴权成功，但是该用户没有权限。</span><br><span class="line"><span class="symbol">404 </span><span class="keyword">not</span> found - 请求的资源不存在</span><br><span class="line"><span class="symbol">405 </span>method <span class="keyword">not</span> allowed - 该http方法不被允许。</span><br><span class="line"><span class="symbol">410 </span>gone - 这个url对应的资源现在不可用。</span><br><span class="line"><span class="symbol">415 </span>unsupported media type - 请求类型错误。</span><br><span class="line"><span class="symbol">422 </span>unprocessable entity - 校验错误时用。</span><br><span class="line"><span class="symbol">429 </span>too many request - 请求过多。</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>原文链接：<a href="http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api" target="_blank" rel="noopener">Vinay Sahni</a>，编译：感谢<a href="http://www.jobbole.com/members/bruce-accumulate/" target="_blank" rel="noopener">@bruce-accumulate</a> 的热心翻译</p><p>译文链接：<a href="http://blog.jobbole.com/41233/" target="_blank" rel="noopener">http://blog.jobbole.com/41233/</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.love4026.org/313851/github-page绑定二级域名/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ray Chang"><meta itemprop="description" content="Think Difficulty"><meta itemprop="image" content="/logo.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Ray's Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/313851/github-page绑定二级域名/" itemprop="url">Github Page绑定二级域名</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-06-16T09:20:14+08:00">2014-06-16</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span></span> <span class="post-meta-divider">|</span><span class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">279</span></span></div></header><div class="post-body" itemprop="articleBody"><p>Github Page绑定二级域名或者顶级域名，需要做两件事，一个是在github page下面创建 CNAME文件，一个就是设置你的DNS。</p><h2 id="CNAME"><a href="#CNAME" class="headerlink" title="CNAME"></a>CNAME</h2><p>创建一个CNAME文件，内容是你的域名，如：<br>domain.org<br>然后把此文件添加到Github仓库，上传到Github。Github服务器会设置domain.org为你的主域名，然后将<a href="http://www.domain.org和demo.github.com重定向到domain.org。" target="_blank" rel="noopener">www.domain.org和demo.github.com重定向到domain.org。</a></p><p>有一个在线的编辑器 <a href="http://prose.io/" target="_blank" rel="noopener">http://prose.io/</a> 使用它可以在线修改你的github page，非常方便，适合不会使用命令的同学。</p><p>如果是想绑定二级域名，上面的设置还是不够的，比如你想把二级域名sub.domain.org 绑定到 demo.github.com ，你需要在CNAME文件里加上sub.demo.org</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>登陆你的域名管理界面。创建一条A记录，指向207.97.227.245这个IP地址。<br>以<code>sub.domain.org</code>为博客域名，指向Github Page。<br>需要做的设置：</p><ul><li>创建CNAME文件，内容为<code>sub.domain.org</code>。</li><li>登陆域名管理，创建CNAME记录，sub -&gt; <code>demo.github.com</code>。</li></ul><p>Github作免费空间有300M的空间限制 。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.love4026.org/313847/嘿，那个上了三天班就辞职的年轻人，我想和你谈/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ray Chang"><meta itemprop="description" content="Think Difficulty"><meta itemprop="image" content="/logo.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Ray's Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/313847/嘿，那个上了三天班就辞职的年轻人，我想和你谈/" itemprop="url">嘿，那个上了三天班就辞职的年轻人，我想和你谈</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-06-14T09:56:54+08:00">2014-06-14</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/转载/" itemprop="url" rel="index"><span itemprop="name">转载</span></a></span></span> <span class="post-meta-divider">|</span><span class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">1,458</span></span></div></header><div class="post-body" itemprop="articleBody"><p>上周招聘了一个年轻人。面试的时候，很有热情，准备充分，对公司也做了研究，连对话提问，明显也是之前有所排练的，总而言之，看起来是一个做事很认真的小伙子。</p><p>他说：我觉得，这就是我想要的公司和文化，这就是我喜欢的工作！<br>这个小伙子戴着黑框眼镜，说这话的时候，一副理想主义者的激情神态。</p><p>坦白说，我被这种神态打动了。<br>我想，也许工作充满繁杂无聊，但只有这种激情，才能造就卓越。</p><p>后来我又看了一下作品，觉得底子不错。决定录用。<br>很快HR给他发了OFFER。第二周就来上班了。</p><p>几天后，他给主管发了一条短信，说自己不喜欢这个工作。发短信第二天，他就不来了。连离职手续都没办。</p><p>主管跟我说起时，我还很惊诧。“这不可能吧？”<br>我觉得这种轻率行为，完全不像是那个年轻人该有的。</p><p>我很想和他谈谈，给他发了条短信。没回复。我准备给他拨个电话，但转念一想，又觉得没这个必要。</p><p>就算打通电话了，我想跟他谈什么呢？</p><p>劝他继续来公司？——不，我不会再要他了。这样的年轻人，我也不敢要。<br>跟他谈什么是“责任”？——都是成年人，也挺没意思。<br>谈“喜欢”和“工作”的关系？——我不是稻盛和夫，我说不出“与其找喜欢的工作，不如喜欢上手头的工作”这种话。</p><p>想来想去，我想给他讲讲我自己的故事。</p><p>我想说说，7年前的自己。</p><p>那时我大学还没毕业，在一家影视广告公司做脚本文案。写脚本很辛苦，影视广告也并不有趣。跟我之前的想象完全不同。</p><p>恰好异地恋的女友来找我。有一天，我跟老板连招呼都没打，跟行政说了一声我不干了，收拾东西就走了。</p><p>手机关机，跟女友过了几天与世隔绝、幸福快乐、没心没肺的日子，我突然觉得该给公司一个交代，于是硬着头皮去公司，找老板谈谈。</p><p>恰巧，在公司电梯口见到老板，带着一群人，扛着大小设备，急匆匆出去外拍。老板见到我，愣了一下，指着我说：等我，回来再跟你说。</p><p>我吓坏了。这个老板平时脾气就大，这下还不得把我训死？</p><p>我在公司提心吊胆等了一个小时。我看着公司其他人忙碌喧哗，根本顾不上理我。难堪之极。</p><p>我找了张纸，写了一封长信，放在前台。算是交代了一下。</p><p>总之，我是落荒而逃。</p><p>这就是我职业生涯的开始。一个不光彩的、污点般的开始。</p><p>我想找那个年轻人，聊聊这件事。</p><p>我想告诉他，这件事成为我后来久久无法磨去的尴尬，心灵上的痒痕。</p><p>在那之后，我经常在洗澡的时候会突然想起自己落荒而逃的身影，内心奇痒无比，忍不住要狂嚎两嗓子才能疏解。</p><p>后来，我正式进入广告传播行业，在一家本土创意公司做了3年，后跟总监出来创业，到今年是第4年。</p><p>2012年的时候，机缘巧合，我又见到了当初那家影视公司的老板。</p><p>毕竟事过多年，我已经有了一颗平常心，能够跟人家主动打招呼了。他还记得我，很热情的跟我握手，问我近况，称赞我“有才华”，看上去一点也记不起来当初在电梯口的尴尬相遇。</p><p>我们一起吃了个饭，相约以后有机会合作。</p><p>此后，我们再也没有见过。</p><p>那次见面之后，我彻底原谅了自己。我也明白了一件事——几乎所有你认为尴尬的事，都只有你自己记得。别人早已忘却或不放在心上，只有你自己，当成久久无法消逝的“心头之痒”。</p><p>回望过去，我那个时候，很喜欢王小波。王小波有一篇文章，叫《工作与人生》。我当时读了没什么大的感受，比不上读《一只特立独行的猪》这么过瘾。<br>但现在回过头再看，这篇文章简直每一个字都写进了我的心里。</p><p>其中有三句，犹得我心：</p><blockquote><p>**第一句是：“人从工作中可以得到乐趣，这是一种巨大的好处。”</p><p>第二句是：“总而言之，干什么都是好的；但要干出个样子来，这才是人的价值和尊严所在。”</p><p>第三句是：“人在工作时，不单要用到手、腿和腰，还要用脑子和自己的心胸。”**</p></blockquote><p>不知不觉，我发现自己在面对工作时，态度与自己的人生偶像完全一致了。这让我感到振奋。<br>仿佛我经历了一次连自己都未察觉的修炼。如今已经印证，修为在身，境界如常。</p><p>而这种面对工作的态度和认知，是从什么时候开始的呢？就是从那段难堪的起点开始的，从那久久无法消散的心头之痒开始的。<br>那段难堪的经历，以及后来不断的自我反省，以及多年来全心投入工作的历练，使我重新认识了“工作”这件事。以及我应该如何对待“工作”。</p><p>是的。假如我有机会再见到那个年轻人，我会跟他谈谈以上这些。</p><p>原文： <a href="http://jianshu.io/p/6ff3d4113be6" target="_blank" rel="noopener">http://jianshu.io/p/6ff3d4113be6</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.love4026.org/313842/bash-shell中命令行选项参数处理/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ray Chang"><meta itemprop="description" content="Think Difficulty"><meta itemprop="image" content="/logo.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Ray's Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/313842/bash-shell中命令行选项参数处理/" itemprop="url">bash shell中命令行选项参数处理</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-06-10T15:42:17+08:00">2014-06-10</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/转载/" itemprop="url" rel="index"><span itemprop="name">转载</span></a></span></span> <span class="post-meta-divider">|</span><span class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">1,634</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>写程序的时候经常要处理命令行参数，本文描述在Bash下的命令行处理方式。</p><p>选项与参数：</p><p>如下一个命令行：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test<span class="selector-class">.sh</span> -f config<span class="selector-class">.conf</span> -v --prefix=/home</span><br></pre></td></tr></table></figure><p>我们称-f为选项，它需要一个参数，即config.conf, -v 也是一个选项，但它不需要参数。</p><p>–prefix我们称之为一个长选项，即选项本身多于一个字符，它也需要一个参数，用等号连接，当然等号不是必须的，/home可以直接写在–prefix后面，即–prefix/home,更多的限制后面具体会讲到。<br>在bash中，可以用以下三种方式来处理命令行参数，每种方式都有自己的应用场景。</p><ul><li>手工处理方式</li><li>getopts</li><li>getopt</li></ul><p>下面我们依次讨论这三种处理方式。</p><h2 id="手工处理方式"><a href="#手工处理方式" class="headerlink" title="手工处理方式"></a>手工处理方式</h2><p>在手工处理方式中，首先要知道几个变量，还是以上面的命令行为例：</p><ul><li>$0 ： ./test.sh,即命令本身，相当于C/C++中的argv[0]</li><li>$1 ： -f,第一个参数.</li><li>$2 ： config.conf</li><li>$3, $4 … ：类推。</li><li>$# 参数的个数，不包括命令本身，上例中$#为4.</li><li>$@ ：参数本身的列表，也不包括命令本身，如上例为 -f config.conf -v –prefix=/home</li><li>$ <em>：和$@相同，但”$</em>“ 和 “$@”(加引号)并不同，”$*”将所有的参数解释成一个字符串，而”$@”是一个参数数组。如下例所示：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="string">"$*"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$arg</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$arg</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>执行<code>./test.sh -f config.conf -n 10</code> 会打印：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">f config.conf -n <span class="number">10</span> <span class="comment">#这是"$*"的输出</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">-f <span class="comment">#以下为$@的输出</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">config.conf</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">-n</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="number">10</span></span></span><br></pre></td></tr></table></figure><p>所以，手工处理的方式即对这些变量的处理。因为手工处理高度依赖于你在命令行上所传参数的位置，所以一般都只用来处理较简单的参数。如</p><p><code>./test.sh 10</code></p><p>而很少使用./test -n 10这种带选项的方式。 典型用法为：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ x<span class="variable">$1</span> != x ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="comment">#...有参数</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="comment">#...没有参数</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p></p><p>为什么要使用 <code>x$1 != x</code>这种方式来比较呢？想像一下这种方式比较：</p><p><code>if [ -n $1 ] #$1</code> 不为空</p><p>但如果用户不传参数的时候，$1为空，这时 就会变成 [ -n ] ,所以需要加一个辅助字符串来进行比较。</p><p>手工处理方式能满足大多数的简单需求，配合shift使用也能构造出强大的功能，但在要处理复杂选项的时候建议用下面的两种方法。</p><h2 id="getopts-getopt"><a href="#getopts-getopt" class="headerlink" title="getopts/getopt"></a>getopts/getopt</h2><p>处理命令行参数是一个相似而又复杂的事情，为此，C提供了getopt/getopt_long等函数，<br>C++的boost提供了Options库，在shell中，处理此事的是getopts和getopt.</p><p>getopts和getopt功能相似但又不完全相同，其中getopt是独立的可执行文件，而getopts是由Bash内置的。</p><p>先来看看参数传递的典型用法:</p><ul><li>./test.sh -a -b -c ： 短选项，各选项不需参数</li><li>./test.sh -abc ： 短选项，和上一种方法的效果一样，只是将所有的选项写在一起。</li><li>./test.sh -a args -b -c ：短选项，其中-a需要参数，而-b -c不需参数。</li><li>./test.sh –a-long=args –b-long ：长选项</li></ul><p>我们先来看getopts,它不支持长选项。</p><p>使用getopts非常简单：<br>代码</p><p>#test.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> <span class="string">"a:bc"</span> arg <span class="comment">#选项后面的冒号表示该选项需要参数</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="keyword">case</span> <span class="variable">$arg</span> <span class="keyword">in</span></span><br><span class="line">             a)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"a's arg:<span class="variable">$OPTARG</span>"</span> <span class="comment">#参数存在$OPTARG中</span></span><br><span class="line">                ;;</span><br><span class="line">             b)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"b"</span></span><br><span class="line">                ;;</span><br><span class="line">             c)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"c"</span></span><br><span class="line">                ;;</span><br><span class="line">             ?)  <span class="comment">#当有不认识的选项的时候arg为?</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"unkonw argument"</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line">        ;;</span><br><span class="line">        <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>现在就可以使用：<br><code>./test.sh -a arg -b -c</code><br>或<br><code>./test.sh -a arg -bc</code><br>来加载了。</p><p>应该说绝大多数脚本使用该函数就可以了，如果需要支持长选项以及可选参数，那么就需要使用getopt.<br>下面是getopt自带的一个例子：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A small example program for using the new getopt(1) program.</span></span><br><span class="line"><span class="comment"># This program will only work with bash(1)</span></span><br><span class="line"><span class="comment"># An similar program using the tcsh(1) script language can be found</span></span><br><span class="line"><span class="comment"># as parse.tcsh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Example input and output (from the bash prompt):</span></span><br><span class="line"><span class="comment"># ./parse.bash -a par1 'another arg' --c-long 'wow!*\?' -cmore -b " very long "</span></span><br><span class="line"><span class="comment"># Option a</span></span><br><span class="line"><span class="comment"># Option c, no argument</span></span><br><span class="line"><span class="comment"># Option c, argument `more'</span></span><br><span class="line"><span class="comment"># Option b, argument ` very long '</span></span><br><span class="line"><span class="comment"># Remaining arguments:</span></span><br><span class="line"><span class="comment"># --&amp;gt; `par1'</span></span><br><span class="line"><span class="comment"># --&amp;gt; `another arg'</span></span><br><span class="line"><span class="comment"># --&amp;gt; `wow!*\?'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Note that we use `"$@"' to let each command-line parameter expand to a</span></span><br><span class="line"><span class="comment"># separate word. The quotes around `$@' are essential!</span></span><br><span class="line"><span class="comment"># We need TEMP as the `eval set --' would nuke the return value of getopt.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#-o表示短选项，两个冒号表示该选项有一个可选参数，可选参数必须紧贴选项</span></span><br><span class="line"><span class="comment">#如-carg 而不能是-c arg</span></span><br><span class="line"><span class="comment">#--long表示长选项</span></span><br><span class="line"><span class="comment">#"$@"在上面解释过</span></span><br><span class="line"><span class="comment"># -n:出错时的信息</span></span><br><span class="line"><span class="comment"># -- ：举一个例子比较好理解：</span></span><br><span class="line"><span class="comment">#我们要创建一个名字为 "-f"的目录你会怎么办？</span></span><br><span class="line"><span class="comment"># mkdir -f #不成功，因为-f会被mkdir当作选项来解析，这时就可以使用</span></span><br><span class="line"><span class="comment"># mkdir -- -f 这样-f就不会被作为选项。</span></span><br><span class="line"></span><br><span class="line">TEMP=`getopt -o ab:c:: --long a-long,b-long:,c-long:: \</span><br><span class="line">     -n <span class="string">'example.bash'</span> -- <span class="string">"<span class="variable">$@</span>"</span>`</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ $? != 0 ] ; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"Terminating..."</span> &amp;gt;&amp;amp;2 ; <span class="built_in">exit</span> 1 ; <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Note the quotes around `$TEMP': they are essential!</span></span><br><span class="line"><span class="comment">#set 会重新排列参数的顺序，也就是改变$1,$2...$n的值，这些值在getopt中重新排列过了</span></span><br><span class="line"><span class="built_in">eval</span> <span class="built_in">set</span> -- <span class="string">"<span class="variable">$TEMP</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#经过getopt的处理，下面处理具体选项。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> ; <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></span><br><span class="line">                -a|--a-long) <span class="built_in">echo</span> <span class="string">"Option a"</span> ; <span class="built_in">shift</span> ;;</span><br><span class="line">                -b|--b-long) <span class="built_in">echo</span> <span class="string">"Option b, argument \`<span class="variable">$2</span>'"</span> ; <span class="built_in">shift</span> 2 ;;</span><br><span class="line">                -c|--c-long)</span><br><span class="line">                        <span class="comment"># c has an optional argument. As we are in quoted mode,</span></span><br><span class="line">                        <span class="comment"># an empty parameter will be generated if its optional</span></span><br><span class="line">                        <span class="comment"># argument is not found.</span></span><br><span class="line">                        <span class="keyword">case</span> <span class="string">"<span class="variable">$2</span>"</span> <span class="keyword">in</span></span><br><span class="line">                                <span class="string">""</span>) <span class="built_in">echo</span> <span class="string">"Option c, no argument"</span>; <span class="built_in">shift</span> 2 ;;</span><br><span class="line">                                *)  <span class="built_in">echo</span> <span class="string">"Option c, argument \`<span class="variable">$2</span>'"</span> ; <span class="built_in">shift</span> 2 ;;</span><br><span class="line">                        <span class="keyword">esac</span> ;;</span><br><span class="line">                --) <span class="built_in">shift</span> ; <span class="built_in">break</span> ;;</span><br><span class="line">                *) <span class="built_in">echo</span> <span class="string">"Internal error!"</span> ; <span class="built_in">exit</span> 1 ;;</span><br><span class="line">        <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Remaining arguments:"</span></span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">'--&amp;gt; '</span><span class="string">"\`<span class="variable">$arg</span>'"</span> ;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>比如我们使用</p><p><code>./test -a -b arg arg1 -c</code></p><p>你可以看到,命令行中多了个arg1参数，在经过getopt和set之后，命令行会变为：<br><code>-a -b arg -c -- arg1</code><br>$1指向-a,$2指向-b,$3指向arg,$4指向-c,$5指向–,而多出的arg1则被放到了最后。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般小脚本手工处理也许就够了，getopts能处理绝大多数的情况，getopt较复杂，功能也更强大。<br>有问题请指出，不胜感激。</p><p>原文：<a href="http://www.cnblogs.com/FrankTan/archive/2010/03/01/1634516.html" target="_blank" rel="noopener">http://www.cnblogs.com/FrankTan/archive/2010/03/01/1634516.html</a><br>参考资料：<a href="http://su1216.iteye.com/blog/1926382" target="_blank" rel="noopener">http://su1216.iteye.com/blog/1926382</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article></section><nav class="pagination"><a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a> <a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/42/">42</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/logo.png" alt="Ray Chang"><p class="site-author-name" itemprop="name">Ray Chang</p><p class="site-description motion-element" itemprop="description">Think Difficulty</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">415</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">10</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">238</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/sbmzhcn" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="https://twitter.com/love4026/" target="_blank" title="Twitter"><i class="fa fa-fw fa-twitter"></i> Twitter</a></span><span class="links-of-author-item"><a href="https://plus.google.com/u/0/106618658391372851068" target="_blank" title="Google Plus"><i class="fa fa-fw fa-google"></i> Google Plus</a></span><span class="links-of-author-item"><a href="https://www.facebook.com/love4026" target="_blank" title="Facebook"><i class="fa fa-fw fa-facebook"></i> Facebook</a></span><span class="links-of-author-item"><a href="https://www.v2ex.com/member/sbmzhcn" target="_blank" title="V2EX"><i class="fa fa-fw fa-globe"></i> V2EX</a></span><span class="links-of-author-item"><a href="mailto:love4026@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span></div><div class="cc-license motion-element" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" class="cc-opacity" target="_blank"><img src="/images/cc-by-nc-nd.svg" alt="Creative Commons"></a></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="http://www.lanthy.com/" title="蓝悉" target="_blank">蓝悉</a></li><li class="links-of-blogroll-item"> <a href="http://www.shibang-china.com/" title="世邦中文" target="_blank">世邦中文</a></li><li class="links-of-blogroll-item"> <a href="http://www.sbmchina.com/" title="世邦英文" target="_blank">世邦英文</a></li><li class="links-of-blogroll-item"> <a href="http://www.kamychina.com/" title="科煤机电" target="_blank">科煤机电</a></li></ul></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">Copyright &copy; <span itemprop="copyrightYear">2018</span><span class="with-love" id="heart"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Ray Chang. Allrights reserved.</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div> <span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4, modified by Ray Chang.</div><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user"></i> 本站访客数<span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 人次</span><span class="site-pv"><i class="fa fa-eye"></i> 本站总访问量<span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css"><script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script></body></html>