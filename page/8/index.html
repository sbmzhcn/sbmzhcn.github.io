<!DOCTYPE html><html class="theme-next pisces use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/logo.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png?v=5.1.4"><link rel="mask-icon" href="/logo.png?v=5.1.4" color="#222"><meta name="keywords" content="Google SEO, 互联网营销, 工业品营销, 矿山机械"><link rel="alternate" href="/atom.xml" title="Ray's Blog" type="application/atom+xml"><meta name="description" content="Google SEO|互联网营销|工业品营销|矿山机械电子商务|B2B、SEM、社交、EDM邮件营销、市场营销"><meta property="og:type" content="website"><meta property="og:title" content="Ray&#39;s Blog"><meta property="og:url" content="http://love4026.org/page/8/index.html"><meta property="og:site_name" content="Ray&#39;s Blog"><meta property="og:description" content="Google SEO|互联网营销|工业品营销|矿山机械电子商务|B2B、SEM、社交、EDM邮件营销、市场营销"><meta property="og:locale" content="zh-Hans"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Ray&#39;s Blog"><meta name="twitter:description" content="Google SEO|互联网营销|工业品营销|矿山机械电子商务|B2B、SEM、社交、EDM邮件营销、市场营销"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://love4026.org/page/8/"><title>Google SEO|互联网营销|工业品营销|矿山机械电子商务|B2B、SEM、社交、EDM邮件营销、市场营销 - Ray's Blog</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Ray's Blog</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">Google SEO|互联网营销|工业矿山机械</h1></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://love4026.org/313864/lnmp下nginx配置ssl安全证书避免启动输入enter-pem-pass-phrase/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ray Chang"><meta itemprop="description" content="Think Difficulty"><meta itemprop="image" content="/logo.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Ray's Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/313864/lnmp下nginx配置ssl安全证书避免启动输入enter-pem-pass-phrase/" itemprop="url">lnmp下nginx配置ssl安全证书避免启动输入enter pem pass phrase</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-06-24T10:28:42+08:00">2014-06-24</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span></span> <span class="post-meta-divider">|</span><span class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">233</span></span></div></header><div class="post-body" itemprop="articleBody"><p>从Startssl免费申请到ssh证书后，把自己的一个网站搭建成了https网站。但是由于生成私钥key文件时输入了密码，导致每次重启nginx时都提示Enter PEM pass phrase ， 这样会导致自己VPS上的重启脚本无法自动工作，每次都要人工重启。</p><p>在网上搜索后找到了解决办法。</p><p>在key的目录执行：<code>openssl rsa -in server.key -out server.key.unsecure</code> 然后在配置文件里使用unsecure这个文件名就行了</p><p>修改后的nginx配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里是SSL的相关配置</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">443</span>;</span><br><span class="line">  <span class="attribute">server_name</span> www.example.com; <span class="comment"># 你自己的域名</span></span><br><span class="line">  <span class="attribute">root</span> /home/wwwroot/www.example.com;</span><br><span class="line">  <span class="attribute">ssl</span> <span class="literal">on</span>;</span><br><span class="line">  <span class="attribute">ssl_certificate</span> /etc/ssl/certs/server.crt;</span><br><span class="line">  <span class="comment"># 修改下面这一行指向我们生成的server.key.unsecure文件</span></span><br><span class="line">  <span class="attribute">ssl_certificate_key</span> /etc/ssl/certs/server.key.unsecure;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用<code>/etc/init.d/nginx restart</code>重启Nginx.不提示便表示成功了。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://love4026.org/313862/restful-api-设计最佳实践/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ray Chang"><meta itemprop="description" content="Think Difficulty"><meta itemprop="image" content="/logo.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Ray's Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/313862/restful-api-设计最佳实践/" itemprop="url">restful api 设计最佳实践</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-06-19T16:01:57+08:00">2014-06-19</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/转载/" itemprop="url" rel="index"><span itemprop="name">转载</span></a></span></span> <span class="post-meta-divider">|</span><span class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">5,202</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>目前互联网上充斥着大量的关于RESTful API（为方便，下文中“RESTful API ”简写为“API”）如何设计的文章，然而却没有一个”万能“的设计标准：如何鉴权？API 格式如何？你的API是否应该加入版本信息？当你开始写一个app的时候，特别是后端模型部分已经写完的时候，你不得不殚精竭虑的设计和实现自己app的public API部分。因为一旦发布，对外发布的API将会很难改变。</p><p>在给SupportedFu设计API的时候，我试图以实用的角度来解决上面提到的问题。我希望可以设计出容易使用，容易部署，并且足够灵活的API，本文因此而生。</p><h2 id="API设计的基本要求"><a href="#API设计的基本要求" class="headerlink" title="API设计的基本要求"></a>API设计的基本要求</h2><p>网上的很多关于API设计的观点都十分”学院派“，它们也许更有理论基础，但是有时却和现实世界脱轨（因此我是自由派）。所以我这篇文章的目标是从实践的角度出发，给出当前网络应用的API设计最佳实践（当然，是我认为的最佳了~），如果觉得不合适，我不会遵从标准。当然作为设计的基础，几个必须的原则还是要遵守的：</p><ol><li>当标准合理的时候遵守标准。</li><li>API应该对程序员友好，并且在浏览器地址栏容易输入。</li><li>API应该简单，直观，容易使用的同时优雅。</li><li>API应该具有足够的灵活性来支持上层ui。</li><li>API设计权衡上述几个原则。</li></ol><p>需要强调的是：API的就是程序员的UI，和其他UI一样，你必须仔细考虑它的用户体验！</p><h2 id="使用RESTful-URLs-和action"><a href="#使用RESTful-URLs-和action" class="headerlink" title="使用RESTful URLs 和action."></a>使用RESTful URLs 和action.</h2><p>虽然前面我说没有一个万能的API设计标准。但确实有一个被普遍承认和遵守：RESTfu设计原则。它被Roy Felding提出（在他的”基于网络的软件架构“论文中<a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm" target="_blank" rel="noopener">第五章</a>）。而REST的核心原则是将你的API拆分为逻辑上的资源。这些资源通过http被操作（GET ,POST,PUT,DELETE）。</p><h2 id="那么我应该如何拆分出这些资源呢？"><a href="#那么我应该如何拆分出这些资源呢？" class="headerlink" title="那么我应该如何拆分出这些资源呢？"></a>那么我应该如何拆分出这些资源呢？</h2><p>显然从API用户的角度来看，”资源“应该是个名词。即使你的内部数据模型和资源已经有了很好的对应，API设计的时候你仍然不需要把它们一对一的都暴露出来。这里的关键是隐藏内部资源，暴露必需的外部资源。</p><p>在SupportFu里，资源是 ticket、user、group。</p><p>一旦定义好了要暴露的资源，你可以定义资源上允许的操作，以及这些操作和你的API的对应关系：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*   GET <span class="string">/tickets</span> <span class="comment"># 获取ticket列表</span></span><br><span class="line">*   GET <span class="string">/tickets/12</span> <span class="comment"># 查看某个具体的ticket</span></span><br><span class="line">*   POST <span class="string">/tickets</span> <span class="comment"># 新建一个ticket</span></span><br><span class="line">*   PUT <span class="string">/tickets/12</span> <span class="comment"># 更新ticket 12.</span></span><br><span class="line">*   DELETE <span class="string">/tickets/12</span> <span class="comment">#删除ticekt 12</span></span><br></pre></td></tr></table></figure><p>可以看出使用REST的好处在于可以充分利用http的强大实现对资源的CURD功能。而这里你只需要一个endpoint：/tickets,再没有其他什么命名规则和url规则了，cool！</p><h2 id="这个endpoint的单数复数"><a href="#这个endpoint的单数复数" class="headerlink" title="这个endpoint的单数复数"></a>这个endpoint的单数复数</h2><p>一个可以遵从的规则是：虽然看起来使用复数来描述某一个资源实例看起来别扭，但是统一所有的endpoint，使用复数使得你的URL更加规整。这让API使用者更加容易理解，对开发者来说也更容易实现。</p><p>如何处理关联？关于如何处理资源之间的管理REST原则也有相关的描述：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*   GET /tickets/<span class="number">12</span>/messages- Retrieves list <span class="keyword">of</span> messages <span class="keyword">for</span> ticket <span class="string">#12</span></span><br><span class="line">*   GET /tickets/<span class="number">12</span>/messages/<span class="number">5</span>- Retrieves <span class="keyword">message</span> <span class="string">#5</span> <span class="keyword">for</span> ticket <span class="string">#12</span></span><br><span class="line">*   POST /tickets/<span class="number">12</span>/messages- Creates a new <span class="keyword">message</span> <span class="keyword">in</span> ticket <span class="string">#12</span></span><br><span class="line">*   PUT /tickets/<span class="number">12</span>/messages/<span class="number">5</span>- Updates <span class="keyword">message</span> <span class="string">#5</span> <span class="keyword">for</span> ticket <span class="string">#12</span></span><br><span class="line">*   PATCH /tickets/<span class="number">12</span>/messages/<span class="number">5</span>- Partially updates <span class="keyword">message</span> <span class="string">#5</span> <span class="keyword">for</span> ticket <span class="string">#12</span></span><br><span class="line">*   DELETE /tickets/<span class="number">12</span>/messages/<span class="number">5</span>- Deletes <span class="keyword">message</span> <span class="string">#5</span> <span class="keyword">for</span> ticket <span class="string">#12</span></span><br></pre></td></tr></table></figure><p>其中，如果这种关联和资源独立，那么我们可以在资源的输出表示中保存相应资源的endpoint。然后API的使用者就可以通过点击链接找到相关的资源。如果关联和资源联系紧密。资源的输出表示就应该直接保存相应资源信息。（例如这里如果message资源是独立存在的，那么上面 GET /tickets/12/messages就会返回相应message的链接；相反的如果message不独立存在，他和ticket依附存在，则上面的API调用返回直接返回message信息）</p><h2 id="不符合CURD的操作"><a href="#不符合CURD的操作" class="headerlink" title="不符合CURD的操作"></a>不符合CURD的操作</h2><p>对这个令人困惑的问题，下面是一些解决方法：</p><ol><li>重构你的行为action。当你的行为不需要参数的时候，你可以把active对应到activated这个资源，（更新使用patch）.</li><li>以子资源对待。例如:github上，对一个gists加星操作：PUT /gists/:id/star 并且取消星操作：DELETE /gists/:id/star.</li><li>有时候action实在没有难以和某个资源对应上例如search。那就这么办吧。我认为API的使用者对于/search这种url也不会有太大意见的（毕竟他很容易理解）。只要注意在文档中写清楚就可以了。<br>4.</li></ol><h2 id="永远使用SSL"><a href="#永远使用SSL" class="headerlink" title="永远使用SSL"></a>永远使用SSL</h2><p>毫无例外，永远都要使用SSL。你的应用不知道要被谁，以及什么情况访问。有些是安全的，有些不是。使用SSL可以减少鉴权的成本：你只需要一个简单的令牌（token）就可以鉴权了，而不是每次让用户对每次请求签名。</p><p>值得注意的是：不要让非SSL的url访问重定向到SSL的url。</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>文档和API本身一样重要。文档应该容易找到，并且公开（把它们藏到pdf里面或者存到需要登录的地方都不太好）。文档应该有展示请求和输出的例子：或者以点击链接的方式或者通过curl的方式（请见openstack的文档）。如果有更新（特别是公开的API），应该及时更新文档。文档中应该有关于何时弃用某个API的时间表以及详情。使用邮件列表或者博客记录是好方法。</p><h2 id="版本化"><a href="#版本化" class="headerlink" title="版本化"></a>版本化</h2><p>在API上加入版本信息可以有效的防止用户访问已经更新了的API，同时也能让不同主要版本之间平稳过渡。关于是否将版本信息放入url还是放入请求头有过争论：<a href="http://stackoverflow.com/questions/389169/best-practices-for-API-versioning" target="_blank" rel="noopener">API version should be included in the URL or in a header</a>. 学术界说它应该放到header里面去，但是如果放到url里面我们就可以跨版本的访问资源了。。（参考openstack）。</p><p>strip使用的方法就很好：它的url里面有主版本信息，同时请求头俩面有子版本信息。这样在子版本变化过程中url的稳定的。变化有时是不可避免的，关键是如何管理变化。完整的文档和合理的时间表都会使得API使用者使用的更加轻松。</p><h2 id="结果过滤，排序，搜索："><a href="#结果过滤，排序，搜索：" class="headerlink" title="结果过滤，排序，搜索："></a>结果过滤，排序，搜索：</h2><p>url最好越简短越好，和结果过滤，排序，搜索相关的功能都应该通过参数实现(并且也很容易实现)。</p><p><strong>过滤：</strong>为所有提供过滤功能的接口提供统一的参数。例如：你想限制get /tickets 的返回结果:只返回那些open状态的ticket–get /tickektsstate=open这里的state就是过滤参数。</p><p><strong>排序：</strong>和过滤一样，一个好的排序参数应该能够描述排序规则，而不业务相关。复杂的排序规则应该通过组合实现：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*   GET /ticketssort=-priority- Retrieves <span class="keyword">a</span> list <span class="keyword">of</span> tickets <span class="keyword">in</span> <span class="keyword">descending</span> order <span class="keyword">of</span> priority</span><br><span class="line">*   GET /ticketssort=-priority,created_at- Retrieves <span class="keyword">a</span> list <span class="keyword">of</span> tickets <span class="keyword">in</span> <span class="keyword">descending</span> order <span class="keyword">of</span> priority. Within <span class="keyword">a</span> specific priority, older tickets are ordered <span class="keyword">first</span></span><br></pre></td></tr></table></figure><p>这里第二条查询中，排序规则有多个rule以逗号间隔组合而成。</p><p><strong>搜索：</strong>有些时候简单的排序是不够的。我们可以使用搜索技术（ElasticSearch和Lucene）来实现（依旧可以作为url的参数）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*   GET /ticketsq=<span class="keyword">return</span>&amp;amp;state=<span class="keyword">open</span>&amp;amp;sort=-priority,created_at- Retrieve the highest priority <span class="keyword">open</span> tickets mentioning the word ‘<span class="keyword">return</span>’</span><br></pre></td></tr></table></figure><p>对于经常使用的搜索查询，我们可以为他们设立别名,这样会让API更加优雅。例如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">get</span> /<span class="attribute">ticketsq</span>=recently_closed -&gt; <span class="builtin-name">get</span> /tickets/recently_closed.</span><br></pre></td></tr></table></figure><h2 id="限制API返回值的域"><a href="#限制API返回值的域" class="headerlink" title="限制API返回值的域"></a>限制API返回值的域</h2><p>有时候API使用者不需要所有的结果，在进行横向限制的时候（例如值返回API结果的前十项）还应该可以进行纵向限制。并且这个功能能有效的提高网络带宽使用率和速度。可以使用fields查询参数来限制返回的域例如：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /ticketsfields=id,subject,customer_name,updated_at&amp;amp;<span class="keyword">state</span>=open&amp;amp;sort=-updated_at</span><br></pre></td></tr></table></figure><h2 id="更新和创建操作应该返回资源"><a href="#更新和创建操作应该返回资源" class="headerlink" title="更新和创建操作应该返回资源"></a>更新和创建操作应该返回资源</h2><p>PUT、POST、PATCH 操作在对资源进行操作的时候常常有一些副作用：例如created_at,updated_at 时间戳。为了防止用户多次的API调用（为了进行此次的更新操作），我们应该会返回更新的资源（updated representation.）例如：在POST操作以后，返回201 created 状态码，并且包含一个指向新资源的url作为返回头</p><h2 id="是否需要-“HATEOAS”"><a href="#是否需要-“HATEOAS”" class="headerlink" title="是否需要 “HATEOAS”"></a>是否需要 “HATEOAS”</h2><p>网上关于是否允许用户创建新的url有很大的异议（注意不是创建资源产生的url）。为此REST制定了HATEOAS来描述了和endpoint进行交互的时候，行为应该在资源的metadata返回值里面进行定义。</p><p>（译注：作者这里认为HATEOAS还不算成熟，我也不怎么理解这段就算了，读者感兴趣可以自己去原文查看）</p><h2 id="只提供json作为返回格式"><a href="#只提供json作为返回格式" class="headerlink" title="只提供json作为返回格式"></a>只提供json作为返回格式</h2><p>现在开始比较一下XML和json了。XML即冗长，难以阅读，又不适合各种编程语言解析。当然XML有扩展性的优势，但是如果你只是将它来对内部资源串行化，那么他的扩展优势也发挥不出来。很多应用（youtube,twitter,box）都已经开始抛弃XML了，我也不想多费口舌。给了google上的趋势图吧：</p><p><img src="http://www.vinaysahni.com/images/201305-xml-vs-json-api.png" alt=""></p><p>当然如果的你使用用户里面企业用户居多，那么可能需要支持XML。如果是这样的话你还有另外一个问题：你的http请求中的media类型是应该和accept 头同步还是和url？为了方便（browser explorability）,应该是在url中(用户只要自己拼url就好了)。如果这样的话最好的方法是使用.xml或者.json的后缀。</p><h2 id="命名方式？"><a href="#命名方式？" class="headerlink" title="命名方式？"></a>命名方式？</h2><p>是蛇形命令（下划线和小写）还是驼峰命名？如果使用json那么最好的应该是遵守JAVASCRIPT的命名方法-也就是说骆驼命名法。如果你正在使用多种语言写一个库，那么最好按照那些语言所推荐的，java，c#使用骆驼，python，ruby使用snake。</p><p>个人意见：我总觉得蛇形命令更好使一些，当然这没有什么理论的依据。有人说蛇形命名读起来更快，能达到20%，也不知道真假<a href="http://ieeexplore.ieee.org/xpl/articleDetails.jsptp=&amp;arnumber=5521745" target="_blank" rel="noopener">http://ieeexplore.ieee.org/xpl/articleDetails.jsptp=&amp;arnumber=5521745</a></p><h2 id="默认使用pretty-print格式，使用gzip"><a href="#默认使用pretty-print格式，使用gzip" class="headerlink" title="默认使用pretty print格式，使用gzip"></a>默认使用pretty print格式，使用gzip</h2><p>只是使用空格的返回结果从浏览器上看总是觉得很恶心(一大坨有没有？～)。当然你可以提供url上的参数来控制使用“pretty print”，但是默认开启这个选项还是更加友好。格外的传输上的损失不会太大。相反你如果忘了使用gzip那么传输效率将会大大减少，损失大大增加。想象一个用户正在debug那么默认的输出就是可读的-而不用将结果拷贝到其他什么软件中在格式化-是想起来就很爽的事，不是么？</p><p>下面是一个例子:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl https://API.github.com/users/veesahni &gt; with-whitespace.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ruby -r json -e <span class="string">'puts JSON JSON.parse(STDIN.read)'</span> &amp;lt; with-whitespace.txt &gt; without-whitespace.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gzip -c with-whitespace.txt &gt; with-whitespace.txt.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gzip -c without-whitespace.txt &gt; without-whitespace.txt.gz</span></span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*   <span class="keyword">without</span>-whitespace.txt- <span class="number">1252</span> <span class="keyword">bytes</span></span><br><span class="line">*   <span class="keyword">with</span>-whitespace.txt- <span class="number">1369</span> <span class="keyword">bytes</span></span><br><span class="line">*   <span class="keyword">without</span>-whitespace.txt.gz- <span class="number">496</span> <span class="keyword">bytes</span></span><br><span class="line">*   <span class="keyword">with</span>-whitespace.txt.gz- <span class="number">509</span> <span class="keyword">bytes</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，多余的空格使得结果大小多出了8.5%（没有使用gzip），相反只多出了2.6%。据说：twitter使用gzip之后它的streaming API传输减少了80%（link:<a href="https://dev.twitter.com/blog/announcing-gzip-compression-streaming-APIs）" target="_blank" rel="noopener">https://dev.twitter.com/blog/announcing-gzip-compression-streaming-APIs）</a>.</p><h2 id="只在需要的时候使用“envelope”"><a href="#只在需要的时候使用“envelope”" class="headerlink" title="只在需要的时候使用“envelope”"></a>只在需要的时候使用“envelope”</h2><p>很多API象下面这样返回结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"data"</span> : &#123;</span><br><span class="line">    <span class="attr">"id"</span> : <span class="number">123</span>,</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"John"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理由很简单：这样做可以很容易扩展返回结果，你可以加入一些分页信息，一些数据的元信息等－这对于那些不容易访问到返回头的API使用者来说确实有用，但是随着“标准”的发展（cors和<a href="http://tools.ietf.org/html/rfc5988#page-6都开始被加入到标准中了），我个人推荐不要那么做。" target="_blank" rel="noopener">http://tools.ietf.org/html/rfc5988#page-6都开始被加入到标准中了），我个人推荐不要那么做。</a></p><h2 id="何时使用envelope？"><a href="#何时使用envelope？" class="headerlink" title="何时使用envelope？"></a>何时使用envelope？</h2><p>有两种情况是应该使用envelope的。如果API使用者确实无法访问返回头，或者API需要支持交叉域请求（通过jsonp）。</p><p>jsonp请求在请求的url中包含了一个callback函数参数。如果给出了这个参数，那么API应该返回200，并且把真正的状态码放到返回值里面（包装在信封里），例如：<br></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">callback_function</span>(&#123;</span><br><span class="line">  <span class="attribute">status_code</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attribute">next_page</span>: <span class="string">"https://.."</span>,</span><br><span class="line">  <span class="attribute">response</span>: &#123;</span><br><span class="line">    ... actual JSON response body ... </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p>同样为了支持无法方法返回头的API使用者，可以允许envelope=true这样的参数。</p><h2 id="在post-put-patch上使用json作为输入"><a href="#在post-put-patch上使用json作为输入" class="headerlink" title="在post,put,patch上使用json作为输入"></a>在post,put,patch上使用json作为输入</h2><p>如果你认同我上面说的，那么你应该决定使用json作为所有的API输出格式，那么我们接下来考虑考虑API的输入数据格式。</p><p>很多的API使用url编码格式：就像是url查询参数的格式一样：单纯的键值对。这种方法简单有效，但是也有自己的问题：它没有数据类型的概念。这使得程序不得不根据字符串解析出布尔和整数,而且还没有层次结构–虽然有一些关于层次结构信息的约定存在可是和本身就支持层次结构的json比较一下还是不很好用。</p><p>当然如果API本身就很简单，那么使用url格式的输入没什么问题。但对于复杂的API你应该使用json。或者干脆统一使用json。</p><p>注意使用json传输的时候，要求请求头里面加入：Content-Type：application/json.，否则抛出415异常（unsupported media type）。</p><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>分页数据可以放到“信封”里面，但随着标准的改进，现在我推荐将分页信息放到link header里面：<a href="http://tools.ietf.org/html/rfc5988#page-6。" target="_blank" rel="noopener">http://tools.ietf.org/html/rfc5988#page-6。</a></p><p>使用link header的API应该返回一系列组合好了的url而不是让用户自己再去拼。这点在基于游标的分页中尤为重要。例如下面，来自github的文档</p><pre class="brush: text; gutter: true">
Link: &lt;https://api.github.com/user/repos?page=3&amp;per_page=100>; rel="next", 
&lt;https://api.github.com/user/repos?page=50&amp;per_page=100>; rel="last"
</pre><h2 id="自动加载相关的资源"><a href="#自动加载相关的资源" class="headerlink" title="自动加载相关的资源"></a>自动加载相关的资源</h2><p>很多时候，自动加载相关资源非常有用，可以很大的提高效率。但是这却<a href="http://idbentley.com/blog/2013/03/14/should-restful-apis-include-relationships/" target="_blank" rel="noopener">和RESTful的原则相背</a>。为了如此，我们可以在url中添加参数：embed（或者expend）。embed可以是一个逗号分隔的串，例如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /ticket/<span class="attribute">12embed</span>=customer.name,assigned_user</span><br></pre></td></tr></table></figure><p>对应的API返回值如下：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"id"</span> : <span class="number">12</span>,</span><br><span class="line">  <span class="string">"subject"</span> : <span class="string">"I have a question!"</span>,</span><br><span class="line">  <span class="string">"summary"</span> : <span class="string">"Hi, ...."</span>,</span><br><span class="line">  <span class="string">"customer"</span> : &#123;</span><br><span class="line">    <span class="string">"name"</span> : <span class="string">"Bob"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  assigned_user: &#123;</span><br><span class="line">   <span class="string">"id"</span> : <span class="number">42</span>,</span><br><span class="line">   <span class="string">"name"</span> : <span class="string">"Jim"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得提醒的是，这个功能有时候会很复杂，并且可能导致<a href="http://stackoverflow.com/questions/97197/what-is-the-n1-selects-issue" target="_blank" rel="noopener">N+1 SELECT 问题</a>。</p><h2 id="重写HTTP方法"><a href="#重写HTTP方法" class="headerlink" title="重写HTTP方法"></a>重写HTTP方法</h2><p>有的客户端只能发出简单的GET 和POST请求。为了照顾他们，我们可以重写HTTP请求。这里没有什么标准，但是一个普遍的方式是接受X-HTTP-Method-Override请求头。</p><h2 id="速度限制"><a href="#速度限制" class="headerlink" title="速度限制"></a>速度限制</h2><p>为了避免请求泛滥，给API设置速度限制很重要。为此 <a href="http://tools.ietf.org/html/rfc6585" target="_blank" rel="noopener">RFC 6585</a> 引入了HTTP状态码<a href="http://tools.ietf.org/html/rfc6585#section-4" target="_blank" rel="noopener">429（too many requests）</a>。加入速度设置之后，应该提示用户，至于如何提示标准上没有说明，不过流行的方法是使用HTTP的返回头。</p><p>下面是几个必须的返回头（依照twitter的命名规则）：</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*   X-Rate-<span class="keyword">Limit</span>-<span class="keyword">Limit</span> :当前时间段允许的并发请求数</span><br><span class="line">*   X-Rate-<span class="keyword">Limit</span>-Remaining:当前时间段保留的请求数。</span><br><span class="line">*   X-Rate-<span class="keyword">Limit</span>-Reset:当前时间段剩余秒数</span><br></pre></td></tr></table></figure><p><strong>为什么使用当前时间段剩余秒数而不是时间戳？</strong></p><p>时间戳保存的信息很多，但是也包含了很多不必要的信息，用户只需要知道还剩几秒就可以再发请求了这样也避免了<a href="http://en.wikipedia.org/wiki/Clock_skew" target="_blank" rel="noopener">clock skew问题</a>。</p><p>有些API使用UNIX格式时间戳，我建议不要那么干。为什么？HTTP 已经规定了使用 <a href="http://www.ietf.org/rfc/rfc1123.txt" target="_blank" rel="noopener">RFC 1123</a> 时间格式</p><h2 id="鉴权-Authentication"><a href="#鉴权-Authentication" class="headerlink" title="鉴权 Authentication"></a>鉴权 Authentication</h2><p>restful API是无状态的也就是说用户请求的鉴权和cookie以及session无关，每一次请求都应该包含鉴权证明。</p><p>通过使用ssl我们可以不用每次都提供用户名和密码：我们可以给用户返回一个随机产生的token。这样可以极大的方便使用浏览器访问API的用户。这种方法适用于用户可以首先通过一次用户名-密码的验证并得到token，并且可以拷贝返回的token到以后的请求中。如果不方便，可以使用OAuth 2来进行token的安全传输。</p><p>支持jsonp的API需要额外的鉴权方法，因为jsonp请求无法发送普通的credential。这种情况下可以在查询url中添加参数：access_token。注意使用url参数的问题是：目前大部分的网络服务器都会讲query参数保存到服务器日志中，这可能会成为大的安全风险。</p><p>注意上面说到的只是三种传输token的方法，实际传输的token可能是一样的。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>HTTP提供了自带的缓存框架。你需要做的是在返回的时候加入一些返回头信息，在接受输入的时候加入输入验证。基本两种方法：</p><p><strong>ETag：</strong>当生成请求的时候，在HTTP头里面加入ETag，其中包含请求的校验和和哈希值，这个值和在输入变化的时候也应该变化。如果输入的HTTP请求包含IF-NONE-MATCH头以及一个ETag值，那么API应该返回304 not modified状态码，而不是常规的输出结果。</p><p><strong>Last-Modified：</strong>和etag一样，只是多了一个时间戳。返回头里的Last-Modified：包含了 <a href="http://www.ietf.org/rfc/rfc1123.txt" target="_blank" rel="noopener">RFC 1123</a> 时间戳，它和IF-MODIFIED-SINCE一致。HTTP规范里面有三种date格式，服务器应该都能处理。</p><h2 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h2><p>就像html错误页面能够显示错误信息一样，API 也应该能返回可读的错误信息–它应该和一般的资源格式一致。API应该始终返回相应的状态码，以反映服务器或者请求的状态。API的错误码可以分为两部分，400系列和500系列，400系列表明客户端错误：如错误的请求格式等。500系列表示服务器错误。API应该至少将所有的400系列的错误以json形式返回。如果可能500系列的错误也应该如此。json格式的错误应该包含以下信息：一个有用的错误信息，一个唯一的错误码，以及任何可能的详细错误描述。如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"code"</span> : <span class="number">1234</span>,</span><br><span class="line">  <span class="attr">"message"</span> : <span class="string">"Something bad happened :-("</span>,</span><br><span class="line">  <span class="attr">"description"</span> : <span class="string">"More details about the error here"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对PUT,POST,PATCH的输入的校验也应该返回相应的错误信息，例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"code"</span> : <span class="number">1024</span>,</span><br><span class="line">  <span class="attr">"message"</span> : <span class="string">"Validation Failed"</span>,</span><br><span class="line">  <span class="attr">"errors"</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"code"</span> : <span class="number">5432</span>,</span><br><span class="line">      <span class="attr">"field"</span> : <span class="string">"first_name"</span>,</span><br><span class="line">      <span class="attr">"message"</span> : <span class="string">"First name cannot have fancy characters"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="attr">"code"</span> : <span class="number">5622</span>,</span><br><span class="line">       <span class="attr">"field"</span> : <span class="string">"password"</span>,</span><br><span class="line">       <span class="attr">"message"</span> : <span class="string">"Password cannot be blank"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">200 </span>ok  - 成功返回状态，对应，<span class="keyword">GET</span>,<span class="keyword">PUT</span>,PATCH,<span class="keyword">DELETE</span>.</span><br><span class="line"><span class="symbol">201 </span>created  - 成功创建。</span><br><span class="line"><span class="symbol">304 </span><span class="keyword">not</span> modified   - HTTP缓存有效。</span><br><span class="line"><span class="symbol">400 </span>bad request   - 请求格式错误。</span><br><span class="line"><span class="symbol">401 </span>unauthorized   - 未授权。</span><br><span class="line"><span class="symbol">403 </span>forbidden   - 鉴权成功，但是该用户没有权限。</span><br><span class="line"><span class="symbol">404 </span><span class="keyword">not</span> found - 请求的资源不存在</span><br><span class="line"><span class="symbol">405 </span>method <span class="keyword">not</span> allowed - 该http方法不被允许。</span><br><span class="line"><span class="symbol">410 </span>gone - 这个url对应的资源现在不可用。</span><br><span class="line"><span class="symbol">415 </span>unsupported media type - 请求类型错误。</span><br><span class="line"><span class="symbol">422 </span>unprocessable entity - 校验错误时用。</span><br><span class="line"><span class="symbol">429 </span>too many request - 请求过多。</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>原文链接：<a href="http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api" target="_blank" rel="noopener">Vinay Sahni</a>，编译：感谢<a href="http://www.jobbole.com/members/bruce-accumulate/" target="_blank" rel="noopener">@bruce-accumulate</a> 的热心翻译</p><p>译文链接：<a href="http://blog.jobbole.com/41233/" target="_blank" rel="noopener">http://blog.jobbole.com/41233/</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://love4026.org/313851/github-page绑定二级域名/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ray Chang"><meta itemprop="description" content="Think Difficulty"><meta itemprop="image" content="/logo.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Ray's Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/313851/github-page绑定二级域名/" itemprop="url">Github Page绑定二级域名</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-06-16T09:20:14+08:00">2014-06-16</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span></span> <span class="post-meta-divider">|</span><span class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">279</span></span></div></header><div class="post-body" itemprop="articleBody"><p>Github Page绑定二级域名或者顶级域名，需要做两件事，一个是在github page下面创建 CNAME文件，一个就是设置你的DNS。</p><h2 id="CNAME"><a href="#CNAME" class="headerlink" title="CNAME"></a>CNAME</h2><p>创建一个CNAME文件，内容是你的域名，如：<br>domain.org<br>然后把此文件添加到Github仓库，上传到Github。Github服务器会设置domain.org为你的主域名，然后将<a href="http://www.domain.org和demo.github.com重定向到domain.org。" target="_blank" rel="noopener">www.domain.org和demo.github.com重定向到domain.org。</a></p><p>有一个在线的编辑器 <a href="http://prose.io/" target="_blank" rel="noopener">http://prose.io/</a> 使用它可以在线修改你的github page，非常方便，适合不会使用命令的同学。</p><p>如果是想绑定二级域名，上面的设置还是不够的，比如你想把二级域名sub.domain.org 绑定到 demo.github.com ，你需要在CNAME文件里加上sub.demo.org</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>登陆你的域名管理界面。创建一条A记录，指向207.97.227.245这个IP地址。<br>以<code>sub.domain.org</code>为博客域名，指向Github Page。<br>需要做的设置：</p><ul><li>创建CNAME文件，内容为<code>sub.domain.org</code>。</li><li>登陆域名管理，创建CNAME记录，sub -&gt; <code>demo.github.com</code>。</li></ul><p>Github作免费空间有300M的空间限制 。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://love4026.org/313847/嘿，那个上了三天班就辞职的年轻人，我想和你谈/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ray Chang"><meta itemprop="description" content="Think Difficulty"><meta itemprop="image" content="/logo.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Ray's Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/313847/嘿，那个上了三天班就辞职的年轻人，我想和你谈/" itemprop="url">嘿，那个上了三天班就辞职的年轻人，我想和你谈</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-06-14T09:56:54+08:00">2014-06-14</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/转载/" itemprop="url" rel="index"><span itemprop="name">转载</span></a></span></span> <span class="post-meta-divider">|</span><span class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">1,458</span></span></div></header><div class="post-body" itemprop="articleBody"><p>上周招聘了一个年轻人。面试的时候，很有热情，准备充分，对公司也做了研究，连对话提问，明显也是之前有所排练的，总而言之，看起来是一个做事很认真的小伙子。</p><p>他说：我觉得，这就是我想要的公司和文化，这就是我喜欢的工作！<br>这个小伙子戴着黑框眼镜，说这话的时候，一副理想主义者的激情神态。</p><p>坦白说，我被这种神态打动了。<br>我想，也许工作充满繁杂无聊，但只有这种激情，才能造就卓越。</p><p>后来我又看了一下作品，觉得底子不错。决定录用。<br>很快HR给他发了OFFER。第二周就来上班了。</p><p>几天后，他给主管发了一条短信，说自己不喜欢这个工作。发短信第二天，他就不来了。连离职手续都没办。</p><p>主管跟我说起时，我还很惊诧。“这不可能吧？”<br>我觉得这种轻率行为，完全不像是那个年轻人该有的。</p><p>我很想和他谈谈，给他发了条短信。没回复。我准备给他拨个电话，但转念一想，又觉得没这个必要。</p><p>就算打通电话了，我想跟他谈什么呢？</p><p>劝他继续来公司？——不，我不会再要他了。这样的年轻人，我也不敢要。<br>跟他谈什么是“责任”？——都是成年人，也挺没意思。<br>谈“喜欢”和“工作”的关系？——我不是稻盛和夫，我说不出“与其找喜欢的工作，不如喜欢上手头的工作”这种话。</p><p>想来想去，我想给他讲讲我自己的故事。</p><p>我想说说，7年前的自己。</p><p>那时我大学还没毕业，在一家影视广告公司做脚本文案。写脚本很辛苦，影视广告也并不有趣。跟我之前的想象完全不同。</p><p>恰好异地恋的女友来找我。有一天，我跟老板连招呼都没打，跟行政说了一声我不干了，收拾东西就走了。</p><p>手机关机，跟女友过了几天与世隔绝、幸福快乐、没心没肺的日子，我突然觉得该给公司一个交代，于是硬着头皮去公司，找老板谈谈。</p><p>恰巧，在公司电梯口见到老板，带着一群人，扛着大小设备，急匆匆出去外拍。老板见到我，愣了一下，指着我说：等我，回来再跟你说。</p><p>我吓坏了。这个老板平时脾气就大，这下还不得把我训死？</p><p>我在公司提心吊胆等了一个小时。我看着公司其他人忙碌喧哗，根本顾不上理我。难堪之极。</p><p>我找了张纸，写了一封长信，放在前台。算是交代了一下。</p><p>总之，我是落荒而逃。</p><p>这就是我职业生涯的开始。一个不光彩的、污点般的开始。</p><p>我想找那个年轻人，聊聊这件事。</p><p>我想告诉他，这件事成为我后来久久无法磨去的尴尬，心灵上的痒痕。</p><p>在那之后，我经常在洗澡的时候会突然想起自己落荒而逃的身影，内心奇痒无比，忍不住要狂嚎两嗓子才能疏解。</p><p>后来，我正式进入广告传播行业，在一家本土创意公司做了3年，后跟总监出来创业，到今年是第4年。</p><p>2012年的时候，机缘巧合，我又见到了当初那家影视公司的老板。</p><p>毕竟事过多年，我已经有了一颗平常心，能够跟人家主动打招呼了。他还记得我，很热情的跟我握手，问我近况，称赞我“有才华”，看上去一点也记不起来当初在电梯口的尴尬相遇。</p><p>我们一起吃了个饭，相约以后有机会合作。</p><p>此后，我们再也没有见过。</p><p>那次见面之后，我彻底原谅了自己。我也明白了一件事——几乎所有你认为尴尬的事，都只有你自己记得。别人早已忘却或不放在心上，只有你自己，当成久久无法消逝的“心头之痒”。</p><p>回望过去，我那个时候，很喜欢王小波。王小波有一篇文章，叫《工作与人生》。我当时读了没什么大的感受，比不上读《一只特立独行的猪》这么过瘾。<br>但现在回过头再看，这篇文章简直每一个字都写进了我的心里。</p><p>其中有三句，犹得我心：</p><blockquote><p>**第一句是：“人从工作中可以得到乐趣，这是一种巨大的好处。”</p><p>第二句是：“总而言之，干什么都是好的；但要干出个样子来，这才是人的价值和尊严所在。”</p><p>第三句是：“人在工作时，不单要用到手、腿和腰，还要用脑子和自己的心胸。”**</p></blockquote><p>不知不觉，我发现自己在面对工作时，态度与自己的人生偶像完全一致了。这让我感到振奋。<br>仿佛我经历了一次连自己都未察觉的修炼。如今已经印证，修为在身，境界如常。</p><p>而这种面对工作的态度和认知，是从什么时候开始的呢？就是从那段难堪的起点开始的，从那久久无法消散的心头之痒开始的。<br>那段难堪的经历，以及后来不断的自我反省，以及多年来全心投入工作的历练，使我重新认识了“工作”这件事。以及我应该如何对待“工作”。</p><p>是的。假如我有机会再见到那个年轻人，我会跟他谈谈以上这些。</p><p>原文： <a href="http://jianshu.io/p/6ff3d4113be6" target="_blank" rel="noopener">http://jianshu.io/p/6ff3d4113be6</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://love4026.org/313842/bash-shell中命令行选项参数处理/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ray Chang"><meta itemprop="description" content="Think Difficulty"><meta itemprop="image" content="/logo.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Ray's Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/313842/bash-shell中命令行选项参数处理/" itemprop="url">bash shell中命令行选项参数处理</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-06-10T15:42:17+08:00">2014-06-10</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/转载/" itemprop="url" rel="index"><span itemprop="name">转载</span></a></span></span> <span class="post-meta-divider">|</span><span class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">1,634</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>写程序的时候经常要处理命令行参数，本文描述在Bash下的命令行处理方式。</p><p>选项与参数：</p><p>如下一个命令行：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test<span class="selector-class">.sh</span> -f config<span class="selector-class">.conf</span> -v --prefix=/home</span><br></pre></td></tr></table></figure><p>我们称-f为选项，它需要一个参数，即config.conf, -v 也是一个选项，但它不需要参数。</p><p>–prefix我们称之为一个长选项，即选项本身多于一个字符，它也需要一个参数，用等号连接，当然等号不是必须的，/home可以直接写在–prefix后面，即–prefix/home,更多的限制后面具体会讲到。<br>在bash中，可以用以下三种方式来处理命令行参数，每种方式都有自己的应用场景。</p><ul><li>手工处理方式</li><li>getopts</li><li>getopt</li></ul><p>下面我们依次讨论这三种处理方式。</p><h2 id="手工处理方式"><a href="#手工处理方式" class="headerlink" title="手工处理方式"></a>手工处理方式</h2><p>在手工处理方式中，首先要知道几个变量，还是以上面的命令行为例：</p><ul><li>$0 ： ./test.sh,即命令本身，相当于C/C++中的argv[0]</li><li>$1 ： -f,第一个参数.</li><li>$2 ： config.conf</li><li>$3, $4 … ：类推。</li><li>$# 参数的个数，不包括命令本身，上例中$#为4.</li><li>$@ ：参数本身的列表，也不包括命令本身，如上例为 -f config.conf -v –prefix=/home</li><li>$ <em>：和$@相同，但”$</em>“ 和 “$@”(加引号)并不同，”$*”将所有的参数解释成一个字符串，而”$@”是一个参数数组。如下例所示：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="string">"$*"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$arg</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$arg</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>执行<code>./test.sh -f config.conf -n 10</code> 会打印：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">f config.conf -n <span class="number">10</span> <span class="comment">#这是"$*"的输出</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">-f <span class="comment">#以下为$@的输出</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">config.conf</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">-n</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"><span class="number">10</span></span></span><br></pre></td></tr></table></figure><p>所以，手工处理的方式即对这些变量的处理。因为手工处理高度依赖于你在命令行上所传参数的位置，所以一般都只用来处理较简单的参数。如</p><p><code>./test.sh 10</code></p><p>而很少使用./test -n 10这种带选项的方式。 典型用法为：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ x<span class="variable">$1</span> != x ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="comment">#...有参数</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="comment">#...没有参数</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p></p><p>为什么要使用 <code>x$1 != x</code>这种方式来比较呢？想像一下这种方式比较：</p><p><code>if [ -n $1 ] #$1</code> 不为空</p><p>但如果用户不传参数的时候，$1为空，这时 就会变成 [ -n ] ,所以需要加一个辅助字符串来进行比较。</p><p>手工处理方式能满足大多数的简单需求，配合shift使用也能构造出强大的功能，但在要处理复杂选项的时候建议用下面的两种方法。</p><h2 id="getopts-getopt"><a href="#getopts-getopt" class="headerlink" title="getopts/getopt"></a>getopts/getopt</h2><p>处理命令行参数是一个相似而又复杂的事情，为此，C提供了getopt/getopt_long等函数，<br>C++的boost提供了Options库，在shell中，处理此事的是getopts和getopt.</p><p>getopts和getopt功能相似但又不完全相同，其中getopt是独立的可执行文件，而getopts是由Bash内置的。</p><p>先来看看参数传递的典型用法:</p><ul><li>./test.sh -a -b -c ： 短选项，各选项不需参数</li><li>./test.sh -abc ： 短选项，和上一种方法的效果一样，只是将所有的选项写在一起。</li><li>./test.sh -a args -b -c ：短选项，其中-a需要参数，而-b -c不需参数。</li><li>./test.sh –a-long=args –b-long ：长选项</li></ul><p>我们先来看getopts,它不支持长选项。</p><p>使用getopts非常简单：<br>代码</p><p>#test.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> <span class="string">"a:bc"</span> arg <span class="comment">#选项后面的冒号表示该选项需要参数</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="keyword">case</span> <span class="variable">$arg</span> <span class="keyword">in</span></span><br><span class="line">             a)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"a's arg:<span class="variable">$OPTARG</span>"</span> <span class="comment">#参数存在$OPTARG中</span></span><br><span class="line">                ;;</span><br><span class="line">             b)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"b"</span></span><br><span class="line">                ;;</span><br><span class="line">             c)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"c"</span></span><br><span class="line">                ;;</span><br><span class="line">             ?)  <span class="comment">#当有不认识的选项的时候arg为?</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"unkonw argument"</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line">        ;;</span><br><span class="line">        <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>现在就可以使用：<br><code>./test.sh -a arg -b -c</code><br>或<br><code>./test.sh -a arg -bc</code><br>来加载了。</p><p>应该说绝大多数脚本使用该函数就可以了，如果需要支持长选项以及可选参数，那么就需要使用getopt.<br>下面是getopt自带的一个例子：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A small example program for using the new getopt(1) program.</span></span><br><span class="line"><span class="comment"># This program will only work with bash(1)</span></span><br><span class="line"><span class="comment"># An similar program using the tcsh(1) script language can be found</span></span><br><span class="line"><span class="comment"># as parse.tcsh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Example input and output (from the bash prompt):</span></span><br><span class="line"><span class="comment"># ./parse.bash -a par1 'another arg' --c-long 'wow!*\?' -cmore -b " very long "</span></span><br><span class="line"><span class="comment"># Option a</span></span><br><span class="line"><span class="comment"># Option c, no argument</span></span><br><span class="line"><span class="comment"># Option c, argument `more'</span></span><br><span class="line"><span class="comment"># Option b, argument ` very long '</span></span><br><span class="line"><span class="comment"># Remaining arguments:</span></span><br><span class="line"><span class="comment"># --&amp;gt; `par1'</span></span><br><span class="line"><span class="comment"># --&amp;gt; `another arg'</span></span><br><span class="line"><span class="comment"># --&amp;gt; `wow!*\?'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Note that we use `"$@"' to let each command-line parameter expand to a</span></span><br><span class="line"><span class="comment"># separate word. The quotes around `$@' are essential!</span></span><br><span class="line"><span class="comment"># We need TEMP as the `eval set --' would nuke the return value of getopt.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#-o表示短选项，两个冒号表示该选项有一个可选参数，可选参数必须紧贴选项</span></span><br><span class="line"><span class="comment">#如-carg 而不能是-c arg</span></span><br><span class="line"><span class="comment">#--long表示长选项</span></span><br><span class="line"><span class="comment">#"$@"在上面解释过</span></span><br><span class="line"><span class="comment"># -n:出错时的信息</span></span><br><span class="line"><span class="comment"># -- ：举一个例子比较好理解：</span></span><br><span class="line"><span class="comment">#我们要创建一个名字为 "-f"的目录你会怎么办？</span></span><br><span class="line"><span class="comment"># mkdir -f #不成功，因为-f会被mkdir当作选项来解析，这时就可以使用</span></span><br><span class="line"><span class="comment"># mkdir -- -f 这样-f就不会被作为选项。</span></span><br><span class="line"></span><br><span class="line">TEMP=`getopt -o ab:c:: --long a-long,b-long:,c-long:: \</span><br><span class="line">     -n <span class="string">'example.bash'</span> -- <span class="string">"<span class="variable">$@</span>"</span>`</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ $? != 0 ] ; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"Terminating..."</span> &amp;gt;&amp;amp;2 ; <span class="built_in">exit</span> 1 ; <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Note the quotes around `$TEMP': they are essential!</span></span><br><span class="line"><span class="comment">#set 会重新排列参数的顺序，也就是改变$1,$2...$n的值，这些值在getopt中重新排列过了</span></span><br><span class="line"><span class="built_in">eval</span> <span class="built_in">set</span> -- <span class="string">"<span class="variable">$TEMP</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#经过getopt的处理，下面处理具体选项。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> ; <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></span><br><span class="line">                -a|--a-long) <span class="built_in">echo</span> <span class="string">"Option a"</span> ; <span class="built_in">shift</span> ;;</span><br><span class="line">                -b|--b-long) <span class="built_in">echo</span> <span class="string">"Option b, argument \`<span class="variable">$2</span>'"</span> ; <span class="built_in">shift</span> 2 ;;</span><br><span class="line">                -c|--c-long)</span><br><span class="line">                        <span class="comment"># c has an optional argument. As we are in quoted mode,</span></span><br><span class="line">                        <span class="comment"># an empty parameter will be generated if its optional</span></span><br><span class="line">                        <span class="comment"># argument is not found.</span></span><br><span class="line">                        <span class="keyword">case</span> <span class="string">"<span class="variable">$2</span>"</span> <span class="keyword">in</span></span><br><span class="line">                                <span class="string">""</span>) <span class="built_in">echo</span> <span class="string">"Option c, no argument"</span>; <span class="built_in">shift</span> 2 ;;</span><br><span class="line">                                *)  <span class="built_in">echo</span> <span class="string">"Option c, argument \`<span class="variable">$2</span>'"</span> ; <span class="built_in">shift</span> 2 ;;</span><br><span class="line">                        <span class="keyword">esac</span> ;;</span><br><span class="line">                --) <span class="built_in">shift</span> ; <span class="built_in">break</span> ;;</span><br><span class="line">                *) <span class="built_in">echo</span> <span class="string">"Internal error!"</span> ; <span class="built_in">exit</span> 1 ;;</span><br><span class="line">        <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Remaining arguments:"</span></span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">'--&amp;gt; '</span><span class="string">"\`<span class="variable">$arg</span>'"</span> ;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p></p><p>比如我们使用</p><p><code>./test -a -b arg arg1 -c</code></p><p>你可以看到,命令行中多了个arg1参数，在经过getopt和set之后，命令行会变为：<br><code>-a -b arg -c -- arg1</code><br>$1指向-a,$2指向-b,$3指向arg,$4指向-c,$5指向–,而多出的arg1则被放到了最后。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般小脚本手工处理也许就够了，getopts能处理绝大多数的情况，getopt较复杂，功能也更强大。<br>有问题请指出，不胜感激。</p><p>原文：<a href="http://www.cnblogs.com/FrankTan/archive/2010/03/01/1634516.html" target="_blank" rel="noopener">http://www.cnblogs.com/FrankTan/archive/2010/03/01/1634516.html</a><br>参考资料：<a href="http://su1216.iteye.com/blog/1926382" target="_blank" rel="noopener">http://su1216.iteye.com/blog/1926382</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://love4026.org/313840/prose-a-wysiwyg-site-editor-for-github/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ray Chang"><meta itemprop="description" content="Think Difficulty"><meta itemprop="image" content="/logo.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Ray's Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/313840/prose-a-wysiwyg-site-editor-for-github/" itemprop="url">Prose——Github所见即所得站点编辑器</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-06-09T18:47:51+08:00">2014-06-09</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/转载/" itemprop="url" rel="index"><span itemprop="name">转载</span></a></span></span> <span class="post-meta-divider">|</span><span class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">689</span></span></div></header><div class="post-body" itemprop="articleBody"><p>结合静态站点托管服务<a href="http://pages.github.com/" target="_blank" rel="noopener">Github Pages</a>与博客生成工具<a href="https://github.com/mojombo/jekyll" target="_blank" rel="noopener">Jekyll</a>，搭建博客站点，有着部署成本低、易于维护的特点。诚然，<a href="https://github.com/mojombo/jekyll" target="_blank" rel="noopener">Jekyll</a>可以与<a href="http://pages.github.com/" target="_blank" rel="noopener">Github Pages</a>无缝集成，专业人士通过pull request就可以发布内容，但不易用是其最大的问题。<a href="http://prose.io/" target="_blank" rel="noopener">Prose</a>是一个基于<a href="http://pages.github.com/" target="_blank" rel="noopener">Github Pages</a>的<a href="https://github.com/mojombo/jekyll" target="_blank" rel="noopener">Jekyll</a>内容编辑器，它的出现使得内容编辑更快、更方便。</p><h2 id="开通Github-Pages服务"><a href="#开通Github-Pages服务" class="headerlink" title="开通Github Pages服务"></a><strong>开通</strong><a href="http://pages.github.com/" target="_blank" rel="noopener"><strong>Github Pages</strong></a><strong>服务</strong></h2><p>从<a href="https://github.com" target="_blank" rel="noopener">Github</a>项目首页，点击进入后台管理页面<br><img src="https://res.infoq.com/news/2012/07/prose-github-content-editor/zh/resources/20120520-dhb4uhf7gx977wfwqbg36wsnxu.png" alt=""></p><p><strong>图1：Github项目管理后台入口<a href="#_Ref1"><sup>[1]</sup></a></strong></p><p>点击”Automatic Page Generator”按钮生成站点服务</p><p><img src="https://res.infoq.com/news/2012/07/prose-github-content-editor/zh/resources/20120602-cqg5dkfeiqd85m5ghah6k1tnff.png" alt=""></p><p><strong>图2：Github项目页面生成器<a href="#_Ref1"><sup>[1]</sup></a></strong></p><p>使用Markdown标记语言编辑站点内容，点击”Continue To Layouts”按钮</p><p><img src="https://res.infoq.com/news/2012/07/prose-github-content-editor/zh/resources/page-generator-picker.png" alt=""></p><p><strong>图3：Github项目页面预览<a href="#_Ref1"><sup>[1]</sup></a></strong></p><p>预览并发布</p><p><img src="https://res.infoq.com/news/2012/07/prose-github-content-editor/zh/resources/page-generator-publish.png" alt=""></p><p><strong>图4：Github项目页面发布<a href="#_Ref1"><sup>[1]</sup></a></strong></p><p>到这里，一个<a href="https://github.com" target="_blank" rel="noopener">Github</a>站点就生成了：http://<span style="color:#000">{<strong>accountName</strong>}</span>.github.com/{<strong><span style="color:#000">projectName</span></strong>}</p><p><strong>使用</strong><a href="http://prose.io/" target="_blank" rel="noopener"><strong>Prose</strong></a><strong>所见即所得的编辑特性</strong></p><p>尝试<a href="http://prose.io/" target="_blank" rel="noopener">Prose</a>非常简单，首先通过<a href="https://github.com/" target="_blank" rel="noopener">Github</a>账户身份验证，便可以导航到相应的站点</p><p><img src="https://res.infoq.com/news/2012/07/prose-github-content-editor/zh/resources/7441016028_3afa9a6397.jpg" alt=""></p><p><strong>图5：Prose验证页面<a href="#_Ref2"><sup>[2]</sup></a></strong></p><p>着陆页会依次列举个人代码库（Repository）</p><p><img src="https://res.infoq.com/news/2012/07/prose-github-content-editor/zh/resources/7441015894_f6866937f5.jpg" alt=""></p><p><strong>图6：Prose代码库列表<a href="#_Ref2"><sup>[2]</sup></a></strong></p><p>选中之前开通<a href="http://pages.github.com/" target="_blank" rel="noopener">Github Pages</a>服务的代码库，可以浏览相应的文件以及创建新的文本文件</p><p><img src="https://res.infoq.com/news/2012/07/prose-github-content-editor/zh/resources/7441016120_903bacee4d.jpg" alt=""></p><p><strong>图7：Prose代码库内容列表<a href="#_Ref2"><sup>[2]</sup></a></strong></p><p>编辑内容的时候，<a href="http://prose.io/" target="_blank" rel="noopener">Prose</a>支持Markdown标签的高亮显示</p><p><img src="https://res.infoq.com/news/2012/07/prose-github-content-editor/zh/resources/7441016244_3d4d614a25.jpg" alt=""></p><p><strong>图8：Prose编辑器高亮特性<a href="#_Ref2"><sup>[2]</sup></a></strong></p><p>任意时刻，都可以点击”Preview”按钮预览当前编辑的内容</p><p><img src="https://res.infoq.com/news/2012/07/prose-github-content-editor/zh/resources/7441016420_2c2a215a5f.jpg" alt=""></p><p><strong>图9：Prose编辑器预览特性<a href="#_Ref2"><sup>[2]</sup></a></strong></p><h2 id="Prose附加特性"><a href="#Prose附加特性" class="headerlink" title="Prose附加特性"></a><a href="http://prose.io/" target="_blank" rel="noopener"><strong>Prose</strong></a><strong>附加特性</strong></h2><p>在菜单工具条点击”M”按钮，可以获取Markdown标签参考语法列表</p><p><img src="https://res.infoq.com/news/2012/07/prose-github-content-editor/zh/resources/synta.jpg" alt=""></p><p><strong>图10：Prose编辑器Markdown语法参考<a href="#_Ref2"><sup>[2]</sup></a></strong></p><p>在菜单沟工具条点击”Metadata”按钮，可以看到文档的元数据以<a href="http://www.yaml.org/" target="_blank" rel="noopener">YAML</a>的格式展现</p><p><img src="https://res.infoq.com/news/2012/07/prose-github-content-editor/zh/resources/meta.jpg" alt=""></p><p><strong>图11：Prose编辑器元数据特性<a href="#_Ref2"><sup>[2]</sup></a></strong></p><h2 id="Prose项目的架构特点与展望"><a href="#Prose项目的架构特点与展望" class="headerlink" title="Prose项目的架构特点与展望"></a><a href="http://prose.io/" target="_blank" rel="noopener"><strong>Prose</strong></a><strong>项目的架构特点与展望</strong></h2><p><a href="http://prose.io/" target="_blank" rel="noopener">Prose</a>的架构实现是以<a href="http://backbonejs.org/" target="_blank" rel="noopener">Backbone</a>与<a href="https://github.com/mojombo/jekyll" target="_blank" rel="noopener">Jekyll</a>为基础，应用托管在<a href="https://github.com/" target="_blank" rel="noopener">Github</a>上，浏览器端直接与<a href="http://developer.github.com/v3/" target="_blank" rel="noopener">GitHub API</a>交互。鉴于浏览器端无法直接与<a href="https://github.com/" target="_blank" rel="noopener">Github</a>通过<a href="http://en.wikipedia.org/wiki/OAuth" target="_blank" rel="noopener">OAuth</a>交互，服务器后端处理用户身份的验证，具体的实现可参照<a href="https://github.com/prose/gatekeeper" target="_blank" rel="noopener">Gatekeeper</a>。</p><p><strong>感兴趣的读者朋友既可以选择</strong><a href="http://prose.io/" target="_blank" rel="noopener"><strong>Prose</strong></a><strong>作为</strong><a href="https://github.com/" target="_blank" rel="noopener"><strong>Github</strong></a><strong>项目博客的内容编辑器，又可以参与</strong><a href="http://prose.io/" target="_blank" rel="noopener"><strong>Prose</strong></a><strong>项目的建设（[<strong>Prose</strong>](<a href="http://prose.io/)完全基于[BSD](http://en.wikipedia.org/wiki/BSD_licenses)开源协议），搭建本地开发环境请参照[http://prose.io/help/internals.html]" target="_blank" rel="noopener">http://prose.io/)完全基于[BSD](http://en.wikipedia.org/wiki/BSD_licenses)开源协议），搭建本地开发环境请参照[http://prose.io/help/internals.html]</a>(<a href="http://prose.io/help/internals.html" target="_blank" rel="noopener">http://prose.io/help/internals.html</a> “<a href="http://prose.io/help/internals.html&quot;" target="_blank" rel="noopener">http://prose.io/help/internals.html&quot;</a>)</strong>。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a><strong>引用</strong></h2><p><a name="_Ref1"></a>[1] <a href="https://help.github.com/articles/creating-pages-with-the-automatic-generator" target="_blank" rel="noopener">https://help.github.com/articles/creating-pages-with-the-automatic-generator</a></p><p><a name="_Ref2"></a>[2] <a href="http://developmentseed.org/blog/2012/june/25/prose-a-content-editor-for-github/" target="_blank" rel="noopener">http://developmentseed.org/blog/2012/june/25/prose-a-content-editor-for-github/</a></p><p>原文： <a href="http://www.infoq.com/cn/news/2012/07/prose-github-content-editor" target="_blank" rel="noopener">http://www.infoq.com/cn/news/2012/07/prose-github-content-editor</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://love4026.org/313838/男人的温柔从哪里体现？/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ray Chang"><meta itemprop="description" content="Think Difficulty"><meta itemprop="image" content="/logo.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Ray's Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/313838/男人的温柔从哪里体现？/" itemprop="url">男人的温柔从哪里体现？</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-06-09T14:04:29+08:00">2014-06-09</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/转载/" itemprop="url" rel="index"><span itemprop="name">转载</span></a></span></span> <span class="post-meta-divider">|</span><span class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">1,296</span></span></div></header><div class="post-body" itemprop="articleBody"><p>谢邀。</p><p>看了一下几个高票答案，讲的都是故事，都很感人，我就不催泪了，不过我需要对这些故事做一个理论补充——男人的温柔是不可能独立存在的。</p><p>So easy，如果一个男人拥有的只是温柔，体贴和任劳任怨，就像是你备胎中最听话的那一位一样。他会因为你的QQ签名改成了“下雨了，心情不好”而打20个电话给你只为给你讲个笑话；他会在你生理期的时候每天给你发短信叫你别着凉and多喝水；他会在你忙到不得不挂掉他电话之首写一封亲笔信来表达他对你的思念。</p><p>如果他只会这些，他不上进，也没有野心，更没有钱，也不会去思考如何赚钱，他有大把的时间，但是他却选择了花在游戏和牵挂你身上。作为女人，你还会喜欢他么？我相信大部分人的答案都是否定的。如果有人就是喜欢这一类男人，那我想说大学里面有很多，很多。</p><p>只有当男人有了足够的能力，社会地位或是财富之后，他的温柔具备杀伤力，我是男人，也是过来人，我知道一点：学习温柔是不需要成本的。换句话说，这玩意基本上不用学都会。一个大老粗也懂得应该对心爱的女人好一点，迁就一点，忍让一点。这在我们童年时期就已经被长辈教育过无数次了。他们总是告诉我们，男孩子要让着女孩子。</p><p>所以男人的温柔并不值钱。只有当这个男人足够强大之后，他的温柔才值钱。因为当一个男人飞黄腾达之后，他的心态会随之膨胀，他会目中无人，他会觉得他有钱有地位所以身边的人都应该围绕着他转。</p><p>很早之前的某一天，本来是要去外地看女朋友，但我犯懒了，那一刻我突然觉得我这么累的在工作，你作为我的女人怎么就不能多为我考虑一下，怎么就不能主动来看我？于是我找了一个理由说临时有工作上的事情去不了了，如果可以的话，不如你过来看我。结果她说，那下个月吧，你有工作就去。听到这句话的时候我生气了，狠狠的生气了。我觉得这女人真的太二，太不懂我。和她分手很久之后，我突然想明白了，二的是我，我已经被越来越高的社会地位冲昏了头脑，我没有做到一个男朋友的分内之事。更别提什么温柔了。我膨胀的太厉害，我失去了为他人思考的能力。我觉得这样下去要完蛋。也就是那时候我突然明白了清华的校训——厚德载物。</p><p>人都是这样，越强大越自傲。这是非常恐怖的，所以傲慢被定为七宗罪之首。同样的例子时时刻刻都在发生，就像是昨天在盐Club的前排会场里，我看到某个大V毫不留情的拒绝了一个粉丝的合影要求，甚至没有一句解释。甚是心寒。</p><p>相反的我看到有很多很强大也很温柔的男人例如马英九，李嘉诚，和《这个杀手不太冷》中的leon。无一不是拥有了强大的能力之后还能够保持一颗善良而谦和内心。我觉得这就是一个男人的温柔。</p><p>当然还有那些网络小说，女人的A片，有哪一个男主角不是家财万贯，武功高强，有勇有谋，帅的一逼？按照他们的人物设定基本可以坐拥天下，傲视众生甚至是扭曲时空。但无独有偶的他们哪一个在女主角面前不是谦谦君子，温润如玉的呢。如果这些男主角身上少了强大或是温柔中的任何一项，女人拿什么来高潮？</p><p>——————————</p><p>我不希望有些朋友带着偏见来看待这个问题，或是拿出现在的男朋友做比较。请不要说类似“不会呀，你看我现在的男朋友虽然没钱，但是他对我好呀”这样的话。那是因为你们在机缘巧合下走到了一起，你开始在这段感情和这个男人身上投资，无论是时间精力还是金钱，时间越长，你投资的就越多，也就越难以抽身。这就像是人们总是会试图维护自己的立场和想法一样，即使你知道那是不对的。</p><p>我更加不希望一些男性同胞误解我在嘲讽，也请不要自我矮化。那不是我的本意。我只是想说出事实，然后我们一起加油。</p><p>知乎原文：<a href="http://www.zhihu.com/question/23853217" target="_blank" rel="noopener">http://www.zhihu.com/question/23853217</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://love4026.org/313832/新入行程序员应知的十个秘密/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ray Chang"><meta itemprop="description" content="Think Difficulty"><meta itemprop="image" content="/logo.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Ray's Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/313832/新入行程序员应知的十个秘密/" itemprop="url">新入行程序员应知的十个秘密</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-06-09T00:57:35+08:00">2014-06-09</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/转载/" itemprop="url" rel="index"><span itemprop="name">转载</span></a></span></span> <span class="post-meta-divider">|</span><span class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">1,219</span></span></div></header><div class="post-body" itemprop="articleBody"><p>初出茅庐的你带着仍残留墨香的毕业证书踏上工作岗位，马上就被书上没写的规则和各种繁杂的日常事务来了个下马威。这样的故事实在是司空见惯，编程工作也不例外。</p><p>没有几个学生能 100% 为自己的第一份真正的工作做好准备。如果你不想成为其中之一，请学学以下这 10 项无需手把手指导就能学会的基本技能：</p><p>1、版本控制系统（VCS）</p><p>VCS 也许是计算机课程最大的疏漏。这些课程光记得教如何写代码，但却往往忘记教学生如何去管理代码。每一个程序员都应该懂得利用 Git 或 Subversion 有效地创建 repository（仓库），编辑与提交代码，进行分支与合并，了解项目工作流。</p><p>2、学会写作</p><p>身为程序员要写的不只有代码。你还要写项目的发布说明，给版本控制写提交消息，在系统里面写漏洞报告。这些和许多地方都需要清晰有效的文字交流—但这个技能计算机科学却很少强调。</p><p>3、正则表达式</p><p>正则表达式本身就是一门语言，每一个现代程序员都要擅长。每一门现代语言都支持正则表达式或者有相关标准库。如果代码需要校验某字符串是否含有 5 个字符、1 个破折号和 1 个数字，你应该马上就能写出 /^[A-Z]{5}-\d$/。</p><p>4、库的使用</p><p>现在已经是 2014 年，所以没人需要用正则表达式从 URL 析取主机名了。因为每一门现代编程语言都有执行常用功能的标准库。</p><p>程序员需要明白，那些经过开发、测试和调试的代码通常要比自己重新写的代码更好。更重要的是，无需编写的代码实现起来要快得多。</p><p>5、SQL</p><p>很多人的 SQL 都是在工作中学会的。数据库怎么会是选修课呢？有不用数据库的吗？</p><p>把数据存进平面文件的时代已经结束了。一切东西都要进出数据库，而 SQL 则是存取数据的语言。这是一门说明性语言，不是程序语言，所以用它来解决问题时需要新的思考方式。每一个程序员都应该了解数据库标准化基础，能够执行 SELECT（及 INNER、OUTER JOIN）、INSERT、UPDATE 和 DELETE。</p><p>6、会用IDE、编辑器及CLI工具</p><p>只懂用锯子的木匠永远也无法出师，所以计算机专业毕业的人只懂 Notepad 或 pico 令人惊诧。编程工具帮助操纵代码及其他数据，令程序员生活变得容易。所以每一个程序员都应该知道命令行、shell 脚本、find、grep 及 sed 的使用。</p><p>7、调试</p><p>每一个程序员都应该知道利用交互式调试器或在代码中点缀一些输出语句来调试程序。通过逐步求精来跟踪问题的能力实在是太重要了。</p><p>8、防错性编程</p><p>错误总是难免的，哪怕是明星程序员也不例外。失控是世界的常态，出错毫不奇怪。防错性编程正是理解了这个事实。如果东西不会不出错，我们就不会检查文件打开成功与否，不会检查客户 ID 是否合法数字，不用测试代码是否允许正确。</p><p>程序员需要知道，编译器告警是有用的工具，可让我们生活得更舒适，而不是要避而远之的麻烦事。每一个程序员都应该知道为什么每一个 PHP 程序都要这样开头：</p><p>set_error_reporting(E_ALL)</p><p>每一个 Perl 程序都要写上这些语句：</p><p>use strict; use warnings;</p><p>9、团队协作</p><p>很少编程工作会让你自己一个人完成，如果你经常这么做，智力会受损，表现会变弱。你的代码必须与别人的交互或者混合。再有才的程序员，如果无法与别人协作，都会给项目造成负面影响，并迅速成为组织的负担。</p><p>10、利用现有代码</p><p>在学校的时候，每一次作业都是一个新项目。但现实世界不是这样的。对于刚工作的人来说，所接到的第一项任务往往是修改代码漏洞。然后，再在现有代码库的基础上为现有系统增加一个小功能。设计新代码那是几个月后的事情，如果幸运的话。</p><p>[本文编译自：blog.newrelic.com]</p><p>原文： <a href="http://www.36kr.com/p/212678.html?ref=related" target="_blank" rel="noopener">http://www.36kr.com/p/212678.html?ref=related</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://love4026.org/313830/log-into-mysql-server-without-password/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ray Chang"><meta itemprop="description" content="Think Difficulty"><meta itemprop="image" content="/logo.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Ray's Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/313830/log-into-mysql-server-without-password/" itemprop="url">无密码登陆mysql服务器</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-06-08T14:47:23+08:00">2014-06-08</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span></span> <span class="post-meta-divider">|</span><span class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">191</span></span></div></header><div class="post-body" itemprop="articleBody"><p>mysql 的一般登陆方式是这样的</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mysql</span> -u <span class="variable">$MYSQL_ROOT</span> -p <span class="variable">$MYSQL_PASS</span> -h <span class="number">192.168.10.1</span></span><br></pre></td></tr></table></figure><p>但是，你有两个方式可以使用无密码提示的登陆，一个是修改<code>/etc/my.cnf</code>文件，一个是修改<code>~/.my.conf</code>文件。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi ~/<span class="selector-class">.my</span><span class="selector-class">.cnf</span></span><br></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="attr">user</span>=alice</span><br><span class="line"><span class="attr">password</span>=alice_passwd</span><br><span class="line"><span class="attr">host</span>=<span class="number">192.168</span>.<span class="number">10.1</span></span><br></pre></td></tr></table></figure><p>如果是修改my.cnf文件，把它加到文件末尾就行了。你可以直接使用</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mysql -u root</span></span><br></pre></td></tr></table></figure><p>登陆，不会再提示密码错误。但如果你仍然使用</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mysql -u root -p</span></span><br></pre></td></tr></table></figure><p>的方式，它还是会提示你输入密码的。</p><p>确保文件是只读的</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod <span class="number">0600</span> ~/<span class="selector-class">.my</span><span class="selector-class">.cnf</span></span><br></pre></td></tr></table></figure><p>这样设置以后，你每次使用命令<code>mysql</code>就可以不要密码了，自动进入mysql中。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://love4026.org/313828/大学仍是跻身中产阶级的门票/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Ray Chang"><meta itemprop="description" content="Think Difficulty"><meta itemprop="image" content="/logo.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Ray's Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/313828/大学仍是跻身中产阶级的门票/" itemprop="url">大学仍是跻身中产阶级的门票</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-06-07T02:25:53+08:00">2014-06-07</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/转载/" itemprop="url" rel="index"><span itemprop="name">转载</span></a></span></span> <span class="post-meta-divider">|</span><span class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">1,904</span></span></div></header><div class="post-body" itemprop="articleBody"><p>一些刚刚走出校门的大学毕业生很难找到工作。其他人则接受了他们觉得大材小用的工作。与此同时，学生债务已经突破1万亿美元大关。</p><p>这足以引发一波关于大学教育是否仍然值得的问题。</p><p>一组新的收入统计数据非常清楚地回答了这些问题：是的，大学值得上，而且差别还不是一丁点。尽管许多年轻的大学毕业生面临种种困境，但一个四年制学位或许从来没有比现在更有价值。</p><p>华盛顿经济政策研究所(Economic Policy Institute)根据劳工部统计数据所做的最新分析显示，大学毕业生和其他人的薪酬差距在去年达到历史最高。2013年，有四年制大学学位的美国人的平均时薪比没有学位的美国人足足高了98%。五年前、10年前和上世纪80年代初的薪酬差距分别是89%、85%和64%。</p><p>这种趋势并没有任何必然性。如果大学毕业生的人数超过经济需要，薪酬差距就会缩小。这种差距的最近一次增长尤为显著，因为它是在大学毕业生数量增长（其部分原因是，许多人在“大衰退”期间重返学校深造）之后出现的。薪酬差距仍然继续增长这一事实意味着，美国培养的大学生依然不够用。</p><p>“目前的大学毕业生太少了，”麻省理工学院(MIT)经济学家大卫·奥特尔(David Autor)说。“准备上大学的人也太少了。”奥特尔并未参与经济政策研究所的分析。</p><p>强调这些不足是非常重要的，因为如今的公开讨论（新闻媒体对此担有一定责任）通常聚焦于一个无可否认的事实：一个学士学位并不能确保成功。当然不能。没有什么东西能确保成功，特别是经过15年令人失望的经济增长和日益严重的不平等之后。</p><p>几乎可以肯定是，当专家和记者花费这么多时间谈论教育的局限性时，他们其实是在劝阻一些青少年不要上大学，成年人不要重返学校攻读学位。（与此同时，这些专家和记者正在送自己的子女上大学，而且经常为应该上哪所大学而困扰。）由于担心不划算而决定不上大学，是一个人在2014年有可能做出的最缺乏经济理性的决策之一。</p><p>受到热烈讨论的上大学成本也无法改变这个事实。根据奥特尔上周四发表于《科学》杂志(Science)的一篇论文，大学学位的真实成本大约是负50万美元。这是正确的：从长远来看，大学教育比免费还便宜。不上大学将使你损失大约50万美元。</p><p>奥特尔这篇论文以经济学家克里斯托弗·艾利(Christopher Avery)和莎拉·特纳(Sarah Turner)的研究成果为基础。它首先通过计算大学学杂费的真实成本得出一个数字，随后用大学毕业生和高中毕业生的终生收入差距减去这个金额。剔除通货膨胀和货币时间价值因素后，上大学的净成本为负50万美元，几乎是30年前的两倍。</p><p>这样计算肯定是不太精确的，因为它没有控制大学毕业生和非大学毕业生预先存在的差异，即无论上不上大学都会存在的差异。然而，还有一些研究在比较了其他方面类似的大学毕业生和非大学毕业生之后，也发现大学教育能够带来丰厚回报。</p><p>与此类似，经济政策研究所的新数据还显示，上大学的好处不仅仅属于通常会继续攻读研究生学位的名牌大学毕业生。只拥有学士学位的人和无学位人群的工资差距也在不断上升。</p><p>但引人注目的是，上过大学但未获得学士学位的人（这一群体还包括社区大学毕业生）的工资溢价并没有上涨。高经济回报属于那些有四年制大学学位的人。这些回报突显了减少大学辍学率的重要性——在《纽约时报杂志》(Times Magazine)最近一篇文章中，保罗·塔夫(Paul Tough)描述了得克萨斯大学(University of Texas)为减少辍学率所做的努力。</p><p>但你肯定听说有不少大学生负债累累，而且还找不到工作，这些令人震惊的故事又该如何解释呢？</p><p>这些轶事可能是真的，但传统思维往往夸大了这个问题。办理贷款的四年制大学毕业生人均负债约2.5万美元，与上大学的经济收益相比，这笔钱显得微乎其微。（扣除通胀因素后，我自己的学生债务几乎等同于这个数字。）拥有学士学位的25至34岁年轻人在4月份的失业率仅仅3%而已。</p><p>我发现经济政策研究所的数据特别耐人寻味。原因是，这家左翼研究机构特意强调，教育并非所有经济问题的解决方案。这也是很重要的。如同几乎所有其他人一样，大学毕业生也正在遭受经济增长乏力，增长收益不成比例地流向最富裕家庭等现象的负面影响。</p><p>过去10年，大学毕业生的平均时薪仅上涨了1%，到大约32.60美元。薪酬差距增大的主要原因是，其他人的平均工资下降了——下降5%，降至大约16.50美元。“在我看来，整体现状是，几乎所有人的工资都没有增长，无论他或她从事何种工作，”该研究所所长劳伦斯·米舍尔(Lawrence Mishel)对我说。“工资的增长趋势在2002年就基本停止了。”</p><p>从整个国家的角度来看，教育只能解决美国经济的部分问题。我们还需要找到其他方式来提升生活水平——更不用说我们需要设法为没有大学学位的人提供好工作。</p><p>但从几乎任何个体的角度来看，上大学是一个无需动脑就可以做出的决定。这是迈入中产阶级乃至更富裕阶层的最可靠的入场券。质疑大学教育价值的人往往是那些明知道自己的孩子将来会上大学的人。</p><p>就在几十年前，高中还被视为教育的前沿。有些人甚至认为，鼓励出身卑微的美国人花费四年光阴上高中是一种浪费。到了今天，每个人都应该接受13年学校教育这种观点显然是不容置疑的。</p><p>但大约13年的教育没有什么神奇之处。随着经济在技术层面变得更加复杂，人们需要接受教育的时间将会上升。在某个时点，15年或17年教育将成为一个更有意义的普遍目标。</p><p>这个时点，其实已经到来。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article></section><nav class="pagination"><a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a> <a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/41/">41</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/logo.png" alt="Ray Chang"><p class="site-author-name" itemprop="name">Ray Chang</p><p class="site-description motion-element" itemprop="description">Think Difficulty</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">410</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">222</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/sbmzhcn" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="https://twitter.com/love4026/" target="_blank" title="Twitter"><i class="fa fa-fw fa-twitter"></i> Twitter</a></span><span class="links-of-author-item"><a href="https://plus.google.com/u/0/106618658391372851068" target="_blank" title="Google Plus"><i class="fa fa-fw fa-google"></i> Google Plus</a></span><span class="links-of-author-item"><a href="https://www.facebook.com/love4026" target="_blank" title="Facebook"><i class="fa fa-fw fa-facebook"></i> Facebook</a></span><span class="links-of-author-item"><a href="https://www.v2ex.com/member/sbmzhcn" target="_blank" title="V2EX"><i class="fa fa-fw fa-globe"></i> V2EX</a></span><span class="links-of-author-item"><a href="mailto:love4026@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span></div><div class="cc-license motion-element" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" class="cc-opacity" target="_blank"><img src="/images/cc-by-nc-nd.svg" alt="Creative Commons"></a></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="http://www.lanthy.com/" title="蓝悉" target="_blank">蓝悉</a></li><li class="links-of-blogroll-item"> <a href="http://www.shibang-china.com/" title="世邦中文" target="_blank">世邦中文</a></li><li class="links-of-blogroll-item"> <a href="http://www.sbmchina.com/" title="世邦英文" target="_blank">世邦英文</a></li><li class="links-of-blogroll-item"> <a href="http://www.kamychina.com/" title="科煤机电" target="_blank">科煤机电</a></li></ul></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">Copyright &copy; <span itemprop="copyrightYear">2018</span><span class="with-love" id="heart"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Ray Chang. Allrights reserved.</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div> <span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4, modified by Ray Chang.</div><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user"></i> 本站访客数<span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 人次</span><span class="site-pv"><i class="fa fa-eye"></i> 本站总访问量<span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css"><script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script></body></html>