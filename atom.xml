<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>leadscloud</title>
  
  <subtitle>Google SEO|外贸营销推广</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://leadscloud.github.io/"/>
  <updated>2019-08-08T04:28:09.356Z</updated>
  <id>https://leadscloud.github.io/</id>
  
  <author>
    <name>Ray</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>把代码从bitbucket迁移到github</title>
    <link href="https://leadscloud.github.io/20190808/bitbucket-to-github/"/>
    <id>https://leadscloud.github.io/20190808/bitbucket-to-github/</id>
    <published>2019-08-08T04:23:10.000Z</published>
    <updated>2019-08-08T04:28:09.356Z</updated>
    
    <content type="html"><![CDATA[<p>github推出免费私人仓库已经很久了，之前的代码都放在bitbucket上面，今天迁移了一个到github上面</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME/Code/repo-<span class="built_in">directory</span></span><br><span class="line">git remote <span class="built_in">rename</span> <span class="built_in">origin</span> bitbucket</span><br><span class="line">git remote add <span class="built_in">origin</span> https://github.com/leadscloud/leadscloud.github.io.git</span><br><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> master</span><br><span class="line"></span><br><span class="line">git remote rm bitbucket</span><br></pre></td></tr></table></figure><p>上面的方法可以保留所有的提交记录。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;github推出免费私人仓库已经很久了，之前的代码都放在bitbucket上面，今天迁移了一个到github上面&lt;/p&gt;
&lt;figure class=&quot;highlight maxima&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
      <category term="技术" scheme="https://leadscloud.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="git" scheme="https://leadscloud.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git设置代理及取消代理</title>
    <link href="https://leadscloud.github.io/20190805/git-config-proxy-unset-proxy/"/>
    <id>https://leadscloud.github.io/20190805/git-config-proxy-unset-proxy/</id>
    <published>2019-08-05T08:45:11.000Z</published>
    <updated>2019-08-08T04:28:09.360Z</updated>
    
    <content type="html"><![CDATA[<h3 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http<span class="selector-class">.proxy</span> <span class="string">'socks5://127.0.0.1:1080'</span></span><br><span class="line">git config --global https<span class="selector-class">.proxy</span> <span class="string">'socks5://127.0.0.1:1080'</span></span><br></pre></td></tr></table></figure><h3 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global --unset http.proxy</span><br><span class="line">git<span class="built_in"> config </span>--global --unset https.proxy</span><br></pre></td></tr></table></figure><h3 id="列出配置清单"><a href="#列出配置清单" class="headerlink" title="列出配置清单"></a>列出配置清单</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global -l</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;设置代理&quot;&gt;&lt;a href=&quot;#设置代理&quot; class=&quot;headerlink&quot; title=&quot;设置代理&quot;&gt;&lt;/a&gt;设置代理&lt;/h3&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p
      
    
    </summary>
    
      <category term="技术" scheme="https://leadscloud.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="git" scheme="https://leadscloud.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>sed替换目录下特定文件</title>
    <link href="https://leadscloud.github.io/20190731/bulk-find-and-replace-from-dir/"/>
    <id>https://leadscloud.github.io/20190731/bulk-find-and-replace-from-dir/</id>
    <published>2019-07-31T05:35:11.000Z</published>
    <updated>2019-08-08T04:28:09.356Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i -e <span class="string">'s/oldstr/newstr/g'</span> `<span class="built_in">find</span> . -name <span class="built_in">config</span>.php`</span><br></pre></td></tr></table></figure><h2 id="sed用法"><a href="#sed用法" class="headerlink" title="sed用法"></a>sed用法</h2><p>sed命令是一个很强大的文本编辑器，可以对来自文件、以及标准输入的文本进行编辑。</p><p>sed命令的基本语法如下：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">[options]</span> commands <span class="string">[inputfile...]</span></span><br></pre></td></tr></table></figure><p><strong>选项与参数：</strong></p><p>-n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。<br>-e ：直接在命令列模式上进行 sed 的动作编辑；<br>-f ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作；<br>-r ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)<br>-i ：直接修改读取的文件内容，而不是输出到终端。</p><p><strong>动作说明： [n1[,n2]]function</strong><br>n1, n2 ：不见得会存在，一般代表『选择进行动作的行数』，举例来说，如果我的动作是需要在 10 到 20 行之间进行的，则『 10,20[动作行为] 』</p><p><strong>function：</strong><br>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～<br>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！<br>d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；<br>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；<br>p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～<br>s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span c
      
    
    </summary>
    
      <category term="Linux" scheme="https://leadscloud.github.io/categories/Linux/"/>
    
    
      <category term="sed" scheme="https://leadscloud.github.io/tags/sed/"/>
    
  </entry>
  
  <entry>
    <title>人类从此走向虚无主义，这要从一张日食照片证实“相对论”说起</title>
    <link href="https://leadscloud.github.io/20190526/2019-05-26/"/>
    <id>https://leadscloud.github.io/20190526/2019-05-26/</id>
    <published>2019-05-26T15:06:00.000Z</published>
    <updated>2019-08-08T04:28:09.356Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>爱因斯坦是个真正的科学家，在所有检验条件得到满足前，他拒绝承认自己的理论“相对论”是有效的。1919 年 5 月 29 日拍到的日全食是对“相对论”一次重要的检验，激起了全世界对这种全新宇宙观的兴趣。</p></blockquote><blockquote><p>保罗·约翰逊在《摩登时代》里指出了整件事的重大意义：</p></blockquote><blockquote><p>“爱因斯坦作为一个世界级的名人在 1919 年的出现，引人注目地说明了科学创新者对人类的双重影响。他们改变了我们对物质世界的认知，增强了我们对它的掌控。但他们也改变了我们的思想观念。第二个影响常常比第一个影响更激进。”</p></blockquote><blockquote><p>“1920 年代初，第一次在通俗层面上流传着这样一个信念：这个世界再也没有任何绝对的东西：时空，善恶，知识，尤其是价值。人们错误地，大概也是不可避免地把相对论跟相对主义混为一谈。”</p></blockquote><blockquote><p>本文经社会科学文献出版社•甲骨文授权，选自《摩登时代》</p></blockquote><p>现代世界始于 1919 年 5 月 29 日。那天，从西非的普林西比岛和巴西的索布拉尔拍到的日食照片证实了一种新的宇宙论是对的。在接下来的半个世纪里，有一点变得显而易见：建立在欧氏几何的直线和伽利略的绝对时间概念基础上的牛顿宇宙论必须做重大修改。牛顿宇宙论已经巍然屹立了 200 多年。它是一个宏大的架构，正是在这一架构之内，发生了欧洲的启蒙运动、工业革命，以及作为 19 世纪典型特征的人类知识、自由和繁荣的巨大扩张。可是，日益强大的望远镜揭示了一些异常现象。特别是，每隔一个世纪，水星的运行就会偏离根据牛顿物理学定律所预计的位置 43 角秒。这是为什么？</p><p>1905 年，当时在伯尔尼市瑞士专利局工作的 26 岁德国犹太人阿尔伯特·爱因斯坦发表了一篇论文，题为《论运动物体的电动力学》，文中提出的理论后来被称作“狭义相对论”。根据爱因斯坦的观察，在某些环境下，长度似乎缩短了，时钟似乎变慢了，这有点类似于绘画中的透视效果。事实上，就其对于我们对这个世界的感知所产生的影响而言，发现时间和空间是相对的而非绝对的度量条件，丝毫不亚于公元前 500~480 年希腊人最早把透视法用于绘画。</p><p>爱因斯坦的独创性堪称天才卓绝，其论证的路子奇特而优雅，被同行们比作一种艺术，这些在世界范围内唤起了人们日益强烈的兴趣。1907 年，他发表了一篇论文，证明一切物质皆有能量，并总结为一个公式：E=mc²，这个公式后来被视为核武竞赛的起跑点。就连第一次世界大战的爆发也没能阻止科学家们密切追踪爱因斯坦对包罗万象的广义相对论所做的探索，这一理论将涵盖引力场，并对牛顿物理学提出全面的修订。1915 年，爱因斯坦完成这一理论的消息传到了伦敦。次年春天，正当英国人准备对索姆河发起那场灾难性的大规模进攻的时候，爱因斯坦的那篇重要论文通过荷兰被偷带到了剑桥，天文学教授、皇家天文学会会长亚瑟·埃丁顿收到了这篇论文。</p><p>1918 年，埃丁顿在一篇提交给物理学会的论文中发表了爱因斯坦的成果，论文的题目叫作《万有引力与相对论原理》。但是，爱因斯坦方法论的本质在于：他坚持认为，他的公式必须得到实验性观察数据的验证，为此，他亲自设计了 3 项专门的检验条件。其中，关键的一项检验是：一束刚好掠过太阳表面的光线必定弯曲 1.745 角秒——两倍于古典牛顿理论所给出的引力弯曲。这个检验涉及拍摄日食，而下一次日食的时间要到 1919 年 5 月29日。在战争结束之前，皇家天文学家弗兰克·戴森爵士设法从早已山穷水尽的政府那里得到了一项承诺：政府答应拨出 1000 英镑，作为普林西比岛和索布拉尔观测探险的经费。</p><p>1919 年 3 月初，探险队启程前的那个晚上，天文学家们在格林尼治皇家天文台戴森爵士的书房里畅谈至深夜，这个天文台是雷恩爵士在 1675~1676 年设计的，当年，牛顿正在鼓捣他的万有引力理论。埃丁顿的助手 E.T.科廷汉将陪他同行，他问了一个十分要命的问题：如果这次日食拍摄的测量结果证明牛顿和爱因斯坦都错了，偏离量是爱因斯坦计算值的两倍，那将会发生什么？戴森说：“那样的话，埃丁顿就会疯掉，你就不得不独自一人打道回府了。”据埃丁顿的笔记说，5 月 29 日上午，普林西比岛雷电交加，暴雨倾盆。下午云开日出，刚好赶上 1 点 30 分的日食。埃丁顿只有 8 分钟时间操作他的拍摄器材。“我没工夫看日食，一直忙着换感光板……我们拍了 16 张照片。”之后，他以一夜两张的速度，用了 6 个晚上来冲印那些感光板。6 月 3 日，他用了一整天时间测量冲洗出来的照片，到晚上，埃丁顿转身对同事说：“科廷汉，你用不着一个人独自回家了。”爱因斯坦是对的。</p><p><img src="http://img.qdaily.com/uploads/20190522160958fsjzviEY9BNQAKx3.jpg-WebpWebW640" alt><br>1919 年 5 月 29 日，英国天体物理学家亚瑟·埃丁顿在普林西比岛拍摄的日全食。图片来自 wikipedia</p><p>这次远征满足了爱因斯坦的两项检验条件，而且，W.W.坎贝尔在 1922 年 9 月的日食期间再次予以了证实。正是爱因斯坦在科学上的一丝不苟，使得他拒绝承认自己的理论是有效的，除非第三项检验条件（“红移”）得到满足。1919 年 12 月 15 日，他写信给埃丁顿说：“如果事实证明，大自然中并不存在这一现象，那么，整个理论就不得不放弃。”事实上，“红移”现象在 1923 年被威尔逊山天文台所证实，而且，打这以后，相对论的实验证据稳步积累。其中，一个最引人注目的实例是 1979~1980 年发现的类星体的引力透镜效应。而在当时，爱因斯坦在专业上的英雄气概就得到了人们的赞赏。在年轻的哲学家卡尔·波普尔和他在维也纳大学的朋友们看来，“对我们来说，那是一次伟大的经历，对我的智力发展拥有持久的影响。”他后来写道：“给我留下最深印象的，是爱因斯坦自己明白无误地声称，如果自己的理论经不住某些检验，他会认为这一理论根本站不住脚……这样一种姿态，截然不同于马克思、弗洛伊德和阿德勒的教条主义，至于这些人的追随者，那就更不用说了。爱因斯坦一直在寻找关键性的实验，这些实验即使符合他的预言，也决不意味着他的理论就站得住脚；正如他最早强调的那样，只要有一次不符合，就足以证明他的理论是站不住脚的。我觉得，这才是真正的科学态度。”</p><p>爱因斯坦的理论，以及埃丁顿为验证这一理论而进行的那次大肆宣扬的远征，在1919 年激起了全世界的巨大兴趣。无论是此前，还是之后，都不曾有哪一次科学验证占据这么多的头版头条，成为一个广为谈论的话题。从 6 月开始，一直到 9 月在伦敦皇家协会的一次人头攒动的会议上正式宣布这一理论得到证实，其间，人们的紧张情绪稳步增长。在 A.N.怀特海（他当时在场）看来，那就像一出希腊戏剧：</p><p>我们就像合唱队一样，纷纷对一次至关重要的事件发展过程中所揭示出来的命运裁决发表评论。整场演出充满了戏剧色彩——传统的仪式，以及背景上悬挂的牛顿画像，无不提醒我们：眼下，在两百多年之后，历史上最伟大的科学归纳将接受它的第一次修正……思想领域的一场伟大冒险终于功德圆满。</p><p>打那以后，爱因斯坦便成了一个全球英雄，全世界每一所著名大学都邀请他去讲学，他走到哪儿都被人群所包围，他那怅然若失的面容被成千上万的人所熟悉，那是心不在焉的自然哲学家的典型模样。他的理论所带来的冲击是直接的，而且越来越不可估量。不过，这正好说明了波普尔后来提出的所谓“非预期后果律”。有无以数计的著作，试图清楚明白地解释广义相对论如何修改了牛顿的观念，以及它如何发挥作用，对普通的凡夫俗子来说，牛顿的那些观念构成了他们对周围世界的理解。爱因斯坦本人这样总结它：“就其最宽泛的意义而言，‘相对论’可以用这样一句话来概括：一切物理现象都具有这样一个特征，它没有给‘绝对运动’概念的引入提供任何基础，或者换一个更简短但并不那么准确的说法，就是：不存在绝对运动。”许多年后，巴克敏斯特·富勒给日本艺术家野口勇发去了一封著名电报，用 249 个单词解释了爱因斯坦的关键公式，堪称简洁凝练的杰作。</p><p>不过，对大多数人来说，大量使用直线和直角的牛顿物理学十分容易理解，可如今，相对论充其量不过是一个模模糊糊的不安之源。按照人们的理解，绝对时间和绝对长度已经被废黜了；运动是曲线的。突然之间，天体运动当中似乎没有什么东西是确定的。正如哈姆雷特所悲叹的那样：“这个世界脱节了。”这就仿佛不停旋转的地球脱了轴，在一个不再符合惯常度量标准的宇宙中漫无目标地漂泊。1920 年代初，第一次在通俗层面上流传着这样一个信念：这个世界再也没有任何绝对的东西：时空，善恶，知识，尤其是价值。人们错误地，大概也是不可避免地把相对论跟相对主义混为一谈。</p><p>对于公众的误解，最痛苦的莫过于爱因斯坦本人。不停地宣扬和误解让他困惑不已，而这些似乎都是他的工作所促成的。1920 年 9 月 9 日，他写信给他的同事马克斯·玻恩说：“就像童话故事里那个碰到什么都变成黄金的人，我现在也是这样，跟我有关的一切都成了报纸上小题大做的话题。”爱因斯坦不是一个遵循教规的犹太人，但他承认有一个上帝。他热情地相信对与错的绝对标准。他的专业生活奉献给了不懈的寻求，不仅寻求真理，而且寻求确信。他坚持认为，这个世界可以分为主观领域和客观领域，客观部分必定能够给予精确的陈述。在科学意义（而非哲学意义）上，他是一个决定论者。在 1920 年代，他发现，量子力学的测不准原理不仅让人无法接受，而且令人厌恶。终其余生，直至 1955 年去世，他都一直尝试着把物理学固定在统一场论中，试图借此驳倒量子力学的理论。他写信给玻恩说：“你相信有一个掷骰子的上帝，而我相信，在一个客观存在的世界上，在一个我试图以胡思乱想的方式去加以掌控的世界上，有完美的规则和秩序。我坚定地相信这一点，但我也希望，有人能够发现一条比我凭运气找到的方法更加实际的途径，或者更准确地说，是一个更加坚实的基础。”但爱因斯坦没能研究出统一场论，不管是在 1920 年代，还是之后。他在有生之年目睹了道德相对主义（这在他看来是一种疾病）成为社会流行病，正如他在有生之年眼睁睁地看着他那个要命的公式导致了核战争的出现。在生命的最后时刻，他说，有时候他真希望自己是个头脑简单的钟表匠。</p><p><img src="http://img.qdaily.com/uploads/20190522161235hHczsRnxNTmebwSf.jpg-WebpWebW640" alt><br>1921 年演讲中的爱因斯坦，图片来自 wikipedia</p><p>爱因斯坦作为一个世界级名人在 1919 年的出现，引人注目地说明了科学创新者对人类的双重影响。他们改变了我们对物质世界的认知，增强了我们对它的掌控。但他们也改变了我们的思想观念。第二个影响常常比第一个影响更激进。科学天才对人类的影响，善也好，恶也罢，远远超过任何政治家或军阀。伽利略的实证主义创造了 17 世纪的自然哲学躁动，而后者正是科学革命和工业革命的先声。牛顿的物理学构成了 18 世纪启蒙运动的框架，也促成了现代民族主义和革命政治的产生。达尔文“适者生存”的观念，无论对于马克思主义的阶级斗争观念，还是对于造就了希特勒主义的种族主义哲学，都是一个关键性的因素。事实上，达尔文观念的政治和社会后果至今依然在塑造着我们自己，正如我们将在本书中看到的那样。公众对相对论的反应也是如此，它是 20 世纪历史进程的主要影响力之一。它是一把刀子，被它的创造者漫不经心地挥舞着，帮助割断了社会的缆索，使之漂离了传统的停泊地：犹太－基督教文化的信仰与道德。</p><p>相对论所带来的冲击，与公众对弗洛伊德学说的接受几乎同时，这使得它的冲击格外有力。到埃丁顿证实爱因斯坦相对论的那个时期，西格蒙德·弗洛伊德已经 50 多岁。他真正原创性的工作大部分是在世纪之交完成的。《梦的解析》（The Interpretation of Dreams）早在 1900 年就出版了。在医学和精神病学的专业圈子里，他是一个颇有争议的名人，在第一次世界大战之前，他就已经建立了自己的学派，并与他最重要的弟子卡尔·荣格发生了一场轰动一时的学术争论。但直到战争结束，他的观念才开始作为通用货币流通开来。</p><p>弗洛伊德学说流传开来的原因在于，旷日持久的堑壕战使得人们的注意力集中在那些由于压力所导致的精神紊乱的病例上：人们通俗地称之为“弹震症”（shell-shock）。一些出身军事世家的名门子弟志愿当兵服役，作战英勇，屡建功勋，突然间精神崩溃了。他们不可能是胆小鬼，也不是疯子。在治疗精神疾病上，除了像吃药、恐吓或电击疗法这些“英勇”的方法之外，弗洛伊德早就以精神分析的方法，提供了另外一种选择。前面说的那些治疗方法一直被大量使用，随着战争艰难地持续，所谓“治愈”变得越来越短命，剂量也就越来越大。当电流增加的时候，病人要么被治死了，要么宁愿自杀，也不愿像宗教裁判所的受害者那样勇敢面对。战后，亲属对病人在军事医院，尤其是维也纳总医院的精神病科所遭受的残酷折磨怒不可遏，从而导致奥地利政府在 1920 年成立了一个调查委员会，委员会请来了弗洛伊德。由此所导致的论战，尽管不了了之，却让弗洛伊德获得了他所需要的世界性名声。从专业上讲，1920 年对他来说是突破之年，那一年，他的第一家精神病诊所在柏林开张，他的弟子和后来的传记作者欧内斯特·琼斯创办了《国际精神分析杂志》（International Journal of Psycho-Analysis）。</p><p>但更加引人注目，从长远来看也更加重要的是：突然之间，弗洛伊德的著作和观念被知识分子和艺术家所发现。正如哈夫洛克·埃利斯当时所说的那样，弗洛伊德不是个科学家，而是个伟大的艺术家；这话让大师颇感愤怒。经过 80 年的实践检验，总的来说，他的治疗方法被证明是代价高昂的失败，只适合哄哄那些闷闷不乐的家伙，而不是治疗有病的人。如今我们知道，精神分析的核心观念在生理学上毫无根据。事实上，在弗洛伊德阐述这些方法的时候，人们还没有发现孟德尔定律和染色体遗传理论，还没有认识到先天性代谢缺陷，也不存在激素和神经刺激机制，这些东西联合起来证明他的治疗方法是无效的。正如彼得·梅达沃爵士所指出的那样，精神分析有点类似于催眠术和颅相学：它包含彼此孤立的真理碎片，但整个理论是错的。此外，正如年轻的卡尔·波普尔当时非常正确地指出的那样，弗洛伊德对待科学验证的态度完全不同于爱因斯坦，而更像马克思。他在阐述自己的理论时，不是使用经得起实验检验和反驳的具体内容，而是使之包罗万象，很难检验。而且，就像马克思的追随者一样，每当看上去能够驳倒其理论的证据出现，他就修改自己的理论，以迎合这些证据。因此，弗洛伊德的信念主体需要连续不断地扩张和渗透，就像一套处在形成时期的宗教体系。不难预料，像荣格那样的内部批评者总是被当作异议者来对待；而像哈夫洛克·埃利斯那样的外部批评者则被视为异教徒。弗洛伊德身上透露出了 20 世纪最糟糕的意识形态救世主的迹象——他有这样一种持续不断的趋势：把那些与自己有分歧的人视为精神上不稳定，需要治疗。埃利斯对其科学地位的贬低被斥为“一种高度升华的抵抗”。就在他和荣格关系破裂之前，弗洛伊德写信给荣格说：“我的倾向是，对待那些表现出抵抗的同行，完全就像对待那些处在相同情境中的病人。” 20 年后，把异议者视为一种必须强制住院治疗的精神疾病在苏联十分盛行，成为政治迫害的一种形式。</p><p>不过话说回来，就算弗洛伊德作品中真正的科学内容并不多，但它具有相当高的文学品质，并且富有想象力。他的德语文风极具魅力，为他赢得了这个国家最高的文学奖：法兰克福歌德奖。他的作品很适合翻译。把现有的弗洛伊德著作翻译成英文在 1920 年代成为一种产业。但是，由于弗洛伊德让自己的观念涵盖了一个不断拓宽的人类活动和人类经验的领域，新的文学作品也就不断涌现出来。弗洛伊德是个诺斯替教徒。他相信存在一个隐秘的知识结构，通过使用他所设计的一些技法，可以透过事物的表象洞察这一知识结构。梦是他的出发点。他写道，“梦与神经症状的构成并无不同。像后者一样，梦似乎稀奇古怪，毫无意义，但是，当我们借助一种技巧（这种技巧稍稍不同于精神分析中所使用的自由联想法）来仔细审视它的时候，就能从它的显在内容中得到它的隐含意义，或者说是它的潜在思想”。</p><p>诺斯替教总是吸引知识分子。弗洛伊德提供了它的一个特别新鲜有趣的例子。在一个所有受过教育的人都为自己的希腊文和拉丁文知识洋洋得意的时代，弗洛伊德对于古典的典故和意象有一种非凡的天才。他迅速领悟到了像詹姆斯·弗雷泽那样的新一代社会人类学家加诸古典神话之上的重要性，后者的《金枝》（The Golden Bough）一书在 1890 年开始面世。梦的意义，神话的作用——在这杯烈性酒中，弗洛伊德搅和进了无所不在的性的迷幻剂，这是他在几乎所有人类行为的根源中找到的。战争打开了关于性的话匣子；战后的那段时期，人们已经习惯了关于性的讨论登上媒体的大雅之堂。弗洛伊德的时代到了。除了文学天赋之外，他还有一些煽情记者的技巧。他能杜撰一些引人注目的口号。像比他更年轻一些的同时代人拉迪亚德·吉卜林一样，弗洛伊德也经常给现代语言增添一些词语和短语：“潜意识”，“幼儿性欲”，“俄狄浦斯情结”，“自卑情结”，“负罪情结”， “ 自我、本我和超我 ” ，“升华”，“深层心理学”，等等。他的某些重要观念，比如对梦进行性方面的解释，或者后来人们所说的“弗洛伊德失语”，有新鲜智力游戏的吸引力。弗洛伊德深知时事话题的价值。1920 年，在欧洲的自杀风潮余波未平的时候，他出版了《超越快乐原则》（Beyond the Pleasure Principle）一书，提出了“死亡本能”的概念，很快就被人们通俗化为“死亡愿望”。1920 年代见证了宗教信仰的进一步急剧衰退，尤其是在受过教育的人当中，这一时期，弗洛伊德有很多时间在致力于剖析宗教，他把宗教看作是纯粹的人类构想。在《幻想的未来》（The Future of an Illusion，1927）一书中，他论述了人类试图缓解愁苦的下意识努力。他写道：“有相当数量的普通人，试图通过妄想改造现实，来保护自己免遭痛苦。人类的宗教必须归类为这种大规模的群体错觉。不用说，任何一个拥有错觉的人从来都认识不到这一点。”</p><p>这似乎是新时代的声音。并非第一次，一个 50 多岁的先知，长期在荒漠中备受冷落，突然间在镀金的年轻一代中找到了痴迷的听众。关于弗洛伊德学说，格外引人注目的是它的变化多端，以及它的无处不在。对于每一件事情，它似乎都有一种新的、激动人心的解释。而且，弗洛伊德有一种特别的技巧，这就是简明扼要地总结范围广泛的学院学科中突然出现的新趋势，凭借这一技巧，他似乎以非凡的派头和专横的信心，把一些已经在精英阶层的头脑中酝酿的观念呈现出来。1920 年代初，很多知识分子发现，多年来，他们一直就是弗洛伊德的信徒，却并不知道这一点。这种吸引力在小说家当中尤其强大，范围从年轻的奥尔德斯·赫胥黎（他那部令人眼花缭乱的《克罗姆·耶娄》［Crome Yellow］出版于 1921 年），一直到忧郁而保守的托马斯·曼，对他来说，弗洛伊德就是一个“传神谕者”。</p><p><img src="http://img.qdaily.com/uploads/20190522161419z7UhPyC4kpZ583DJ.jpg-WebpWebW640" alt><br>西格蒙德·弗洛伊德，1921年。图片来自 Wikipedia</p><p>爱因斯坦和弗洛伊德对知识分子和艺术家的影响更大，即将到来的和平使他们意识到，一场根本性的变革一直在而且至今依然在整个文化界发生着，相对论的观念和弗洛伊德学说既是这场变革的先兆，也是它的回声。这场变革在战前就有很深的根源。它早在 1905 年就已经开始了，当时，一场公开演说为它吹响了号角，俄罗斯芭蕾舞团的演出经理谢尔盖·佳吉列夫再恰当不过地发表了这篇演说：</p><p>我们是历史上最伟大的总结性时刻的见证者，以一种新的未知文化的名义，这一文化将由我们来创造，也必将把我们席卷而去。正因为如此，我才毫不犹疑地向着美丽宫殿的残壁颓垣，也向着一种新美学的新戒律，举起我手中的酒杯。作为一个不可救药的享乐主义者，我能表达的唯一希望是，即将到来的这场战斗不要损害了生活中的赏心乐事，死亡就像复活一样美丽，一样明亮。</p><p>正如佳吉列夫所言，野兽派的第一次展览将在巴黎举行。1913 年，佳吉列夫把斯特拉文斯基的《春之祭》（Sacre du Printemps）搬上了舞台；到那时，勋伯格已经发表了他的无调性《三首钢琴曲》，奥尔本·贝尔格发表了他的《弦乐四重奏》（作品 3 号）；马蒂斯发明了“立体派”这个术语。也正是在 1909 年，未来派发表了他们的宣言，库尔特·希勒在柏林创办了他的“新俱乐部”，它是一场艺术运动的策源地，这场运动将在 1911 年首次被称作“表现主义”。1920 年代的几乎所有重要艺术人物都已经在 1914 年以前发表、展览或演出过自己的作品，在这个意义上，现代主义运动可以说是一个战前现象。但是，需要一场巨大斗争所带来的剧烈动荡，需要它所促成的政治体制的分崩离析，只有这样才能给现代主义带来它迄今为止所缺乏的激进的政治维度，并让它感知到一个已经土崩瓦解的世界，而它正是在这个旧世界的废墟上构建一个新的世界。因此，佳吉列夫在 1905 年奏响的那挽歌般的（甚至是不安的）音符引人注目地反映出敏锐的洞察力。这场变革的文化和政治两个方面密不可分，正如 1790~1830 年的革命和浪漫主义运动不可分割一样。我们注意到，1916 年，詹姆斯·乔伊斯、特里斯坦·查拉和列宁全都作为流亡者客居苏黎世，在等待他们的时机。</p><p>随着第一次世界大战的结束，现代主义在宣传的炫目强光中登上了一个似乎空荡荡的舞台。1918 年 11 月 9 日晚上，表现主义知识分子的一次会议在柏林的国会大厦召开，会议要求剧院国有化，政府补贴艺术行业，解散所有专业学会。超现实主义大概打算给予弗洛伊德的观念以视觉表达——尽管它的起源完全是独立的——它有自己的行动计划，正如未来主义和达达主义一样。但这只是表面的泡沫。更深层地看，正是相对论所导致的空间和时间的迷惑，正是弗洛伊德的性理论，在新的创造模式中被认为是典型特征。1919 年 6 月 23 日，马塞尔·普鲁斯特出版了《在少女们身旁》（à L’Ombre des jeunes filles），这是一次巨大实验的开始，其实验的领域是破碎的时间和隐秘的性情绪，而这些正是人们新的关注焦点的缩影。6 个月之后，12 月 10 日，普鲁斯特被授予龚古尔奖，法国文学的重心做出了一次决定性的转移，远离了幸存的 19 世纪大师。当然，迄今为止，这样的作品还只是在一些有影响力的少数人当中流传。普鲁斯特不得不自掏腰包印行这部作品的第一卷，并以生产成本的三分之一销售它们（甚至迟至 1956 年，全套《追忆似水年华》［A la recherche du temps perdu］每年的销售量也不足 10000 套）。詹姆斯·乔伊斯也在巴黎，他根本不可能在英伦诸岛发表作品。他的《尤利西斯》（Ulysses）完成于 1922 年，不得不由一家私营印刷所印行，然后偷运过边境。但它的意义并没有被人忽略。没有一部长篇小说比这部小说更清楚地说明了弗洛伊德的观念在何种程度上进入了文学的语言。也是在 1922 年，诗人 T.S.艾略特（他本人最近被认为是时代的先知）写道：它“摧毁了整个 19 世纪”。普鲁斯特和乔伊斯，这两位伟大的先驱和重心转移者，在他们无意间共享的宇宙观中都没有对方的位置。1922 年 5 月 18 日，他们在巴黎会面了，那是斯特拉文斯基的《狐狸》首演结束之后为佳吉列夫和全体演员举办的派对，作曲家和他的舞台设计师巴勃罗·毕加索也出席了这场派对。普鲁斯特此前已经冒犯过了斯特拉文斯基，他很不明智地让乔伊斯顺道搭乘他的出租车回家。这个醉醺醺的爱尔兰人告诉普鲁斯特，自己一个字都没读过他的作品，被激怒的普鲁斯特则回敬道，自己在驱车前往里兹饭店（他在那儿的夜晚随时都有约会）之前也从未读过乔伊斯的作品。6 个月之后，普鲁斯特去世，但在这之前，著名数学家卡米尔·韦塔德已经在一篇文章中把他奉为爱因斯坦的文学诠释者。乔伊斯在他的《芬尼根守灵夜》（Finnegans Wake）中用一句双关语“Prost bitte”把他给打发了。</p><p>有人认为，像普鲁斯特和乔伊斯这样一些作家（当然还包括爱因斯坦和弗洛伊德的观念）“摧毁”了 19 世纪，这个观点并不像看上去的那么异想天开。19 世纪见证了个人责任哲学——我们每个人都分别对自己的行为负有责任的观念——的高潮，那是犹太－基督教和古典世界的共同遗产。正如莱昂内尔·特里林在分析艾略特对《尤利西斯》的裁定时所指出的那样，在19世纪，像沃尔特·佩特（在《文艺复兴》［The Renaissance］一书中）这样重要的美学家完全可以把“以一束猛烈的、像宝石一样的火焰燃烧”的能力归类为“生活中的成功”。“在 19 世纪，”特里林写道，即使“像佩特那样优雅而超然的人，也可以理所当然地根据个人的生活做出成功或失败的判断。”19 世纪的长篇小说本质上都涉及个体在道德上或精神上的成功。《追忆似水年华》和《尤利西斯》不仅标志着反英雄的闪亮登场，而且标志着个人英雄主义作为想象性创造的核心元素的毁灭，以及不屑一顾地摒弃了对道德平衡和道德裁决的关切。个人自由的行使将不再是人类行为中极其有趣的特征。</p><p>这与塑造时代的新兴力量完全符合。马克思主义如今第一次小心翼翼地登上了权力的宝座，是诺斯替教的另一种形式，它声称自己能够透过事物的表象，从经验上洞察其背后隐藏的真理。马克思有一席话，引人注目地预示了我刚刚引用过的弗洛伊德的那段话，他说：“表面上看到的经济关系的最终模式……与其内在的然而却是隐藏着的根本模式有很大的不同，实际上完全相反。”表面上，人们似乎在行使他们的自由意志，做出判断，决定事件。但实际上，在那些熟悉辩证唯物主义方法的人看来，这样的个体，不管多么强大，都不过是一些漂浮物，被经济力量那无法抗拒的汹涌大潮冲来冲去。个体的表面行为只不过隐藏了他们几乎完全不知道的却又无力反抗的阶级模式。</p><p>同样，在弗洛伊德的分析中，个人良心（这是犹太－基督教伦理的核心，也是个人主义实现成功的主要发动机）被视为一种纯粹的安全装置，被集体创造出来，以保护文明秩序免遭人类存在的可怕攻击。弗洛伊德主义包括很多东西，但是，如果说它有一个本质的话，那就是对罪的描述。1920 年，弗洛伊德写道：“严酷无情的超我与服从于超我的自我之间存在着一种紧张的关系，我们把这一紧张称为‘负罪感’（the sense of guilt），文明已经通过弱化并消除这种负罪感，通过在其内部建立一个代理机构来监视它（就像在一座被征服的城市里派出一支驻军那样），从而控制了人们渴望攻击别人这样一种危险的欲望。”负罪感因此不是缺德的标志，而是美德的标志。超我或良心是个体为了保全文明而支付的昂贵代价，它在痛苦中投入的成本将会随着文明的进步而不可阻挡地增加：“先兆性的外在不幸……被转换为永久性的内在不幸，被转换为负罪感所带来的紧张。”弗洛伊德说，他旨在向人们展示：任何人性弱点都无法解释的负罪感是“文明发展中最重要的问题”。正如社会学家已经暗示的那样，就创造出那些使得犯罪和恶行变得不可避免的条件而言，社会很可能是共同犯罪的。但是，个人的负罪感是一种应当驱除的错觉。我们当中没有一个人是个别犯罪；我们全都有罪。</p><p>马克思、弗洛伊德和爱因斯坦全都把同样的信息传递给了 1920 年代：这个世界并不是它看上去的那个样子。意识的经验主义感知塑造了我们的很多观念：时间与距离，对与错，法律与正义，以及社会中人的行为的特性。但意识并不值得信赖。此外，马克思和弗洛伊德的分析，以它们各自不同的方式，联合起来侵蚀了高度发展的个人责任感以及一套既定的、客观上真实有效的道德法则的基础，而这些正是 19 世纪文明的核心。人们从爱因斯坦那里得到了这样一个印象：在这个宇宙中，一切价值衡量都是相对的，这个印象有助于证实他们对道德混乱的想象——这一想象既让人惊愕，又令人兴奋。</p><p>正如 W.B.叶芝所写的那样，“这个世界上所释放出来的”难道不是“纯粹的混乱”吗？在很多人看来，第一次世界大战似乎是罗马衰亡以来最大的灾难。德国出于恐惧和野心，而奥地利则出于顺从和绝望，都是以一种其他交战国不曾有过的方式想要这场战争。它标志着德国哲学中悲观主义浪潮的顶峰，这是战前时期它最显著的特征。德国的悲观主义与美国、英国、法国甚至还有俄国在 1914 年之前的那十年建立在政治变革基础上的乐观主义形成了鲜明对比，它不是知识界的财产，而是在德国社会的每一个阶层（尤其是顶级阶层）中都可以找到。在这场大决战爆发之前，贝特曼·霍尔维格的秘书和亲信库尔特·里茨勒就发出了有点阴郁的音符，他的主人正是以这样一种态度把德国和欧洲领入了深渊，里茨勒说：“总理预料，战争——不管它的结果如何——必将导致现存一切的连根拔除。现存的这个世界已经非常过时，没有理念。”7 月 27 日，他写道：“在劫难逃的厄运比高悬于欧洲和我们这个民族头上的人的权力更大。”贝特曼·霍尔维格和弗洛伊德出生于同一年，他仿佛就是“死亡本能”的化身，而后者正是在那个恐怖的十年结束时杜撰出了这个词。像大多数受过教育的德国人一样，霍尔维格也读过 1895 年出版的马克斯·诺尔道的《退化》（Degeneration），并熟悉意大利犯罪学家切萨雷·龙勃罗梭的退化理论。不管有没有战争，人类都在不可避免地退化；文明正在朝着毁灭迈进。这样的观念在中欧早已是陈词滥调，为人们认可奥斯瓦尔德·斯宾格勒的《西方的衰落》（Decline of the West）铺平了道路，而这本书碰巧出版于 1918 年，当时，那场预言中的自杀已经实现。</p><p>再往西边，在英国，约瑟夫·康拉德（他本人是个东欧人）是反映这种悲观主义的唯一一位重要作家，他围绕这一主题创作了一系列引人注目的长篇小说：《诺斯托罗莫》（Nostromo，1904），《密探》（The Secret Agent，1907），《在西方眼睛下》（Under Western Eyes，1911），《胜利》（Victory，1915）。这些绝望的政治布道词，披着小说的外衣，宣扬了一个预言，托马斯·曼将在 1924 年以他的《魔山》（The Magic Mountain）一书向中欧宣布这一预言，正如他两年后在《密探》德译本的序言中所承认的那样。在康拉德看来，这场战争只不过证实了人类困境的不可救药。从 60 年后的视角去看，一定有人说：康拉德是那个时代唯一其远见在每个细节上都依然清晰而真实的重要作家。他把马克思主义斥为恶毒的胡说八道，肯定会产生令人恐怖的暴政；而弗洛伊德的观念不过是一种“魔法秀”。这场战争证明了人的弱点，但在另外的方面，它不会解决任何问题，也不会产生任何东西。庞大的改革计划，包治百病的万灵药，一切“解决办法”，都是虚幻的。1922 年 10 月 23 日，康拉德写信给伯特兰·罗素（罗素不久前在他新近出版的一本书《中国问题》［The Problem of China］中提出了一些解决办法），他在信中坚持认为：“在任何人的书里或谈话中我都找不到任何东西足以对抗我根深蒂固的感觉：人类居住的这个世界在劫难逃……对中国人来说，对我们其余的人来说，唯一的疗救之道是内心的改变。但看看过去 2000 年的历史，没有太多的理由指望这种事情，就算人已经开始飞……他也不可能像鹰那样飞，他只能像虫子那样飞。”</p><p>在战争开始的时候，康拉德的怀疑论在盎格鲁－撒克逊的世界十分少见。有人把战争本身看作进步的一种形式。H.G.威尔斯在一本名为《终结战争的战争》（The War That Will End War）的书中宣布了这一观点。但是，到了停战的时候，维多利亚时代的人所理解的那种意义上的进步，就像某种连续不断的、几乎是不可阻挡的事物一样，也彻底消亡了。1920 年，伟大的古典学者 J.B.伯里在《进步的观念》（The Idea of Progress）一书中，宣布了它的死亡。“一种新的观念将会篡夺人类指导观念的位置……进步本身难道没有暗示这样一个观点吗：作为一种学说，它的价值仅仅是相对的，只不过是相对于某个不是很先进的文明阶段而言。” </p><p><img src="http://img.qdaily.com/uploads/20190522161118VErueg2Z1vhdHQPo.jpeg-WebpWebW640" alt><br>题图、长题图来自 unsplash</p><p>转载自：<a href="http://www.qdaily.com/articles/63960.html" target="_blank" rel="noopener">http://www.qdaily.com/articles/63960.html</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;爱因斯坦是个真正的科学家，在所有检验条件得到满足前，他拒绝承认自己的理论“相对论”是有效的。1919 年 5 月 29 日拍到的日全食是对“相对论”一次重要的检验，激起了全世界对这种全新宇宙观的兴趣。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;bloc
      
    
    </summary>
    
      <category term="转载" scheme="https://leadscloud.github.io/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="科学" scheme="https://leadscloud.github.io/tags/%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>启用 macOS 原生的U盘读写NTFS功能</title>
    <link href="https://leadscloud.github.io/20190521/macos-enable-ntfs-write/"/>
    <id>https://leadscloud.github.io/20190521/macos-enable-ntfs-write/</id>
    <published>2019-05-21T15:01:00.000Z</published>
    <updated>2019-08-08T04:28:09.364Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>默认情况下，把一个NTFS格式的磁盘插入到Mac里，是只能读不能写的。网上一直流传着这么一个简单的方法是用第三方工具，Paragon NTFS for MAC。但是要收费，第二就是破解版还不一定能运行。其实最早在OSX 10.5的时候，OSX其实原生就支持直接写入NTFS的盘的，后来由于微软的限制，把这个功能给屏蔽了，我们可以通过命令行手动打开这个选项。</p></blockquote><h2 id="先插入你的-U-盘"><a href="#先插入你的-U-盘" class="headerlink" title="先插入你的 U 盘"></a>先插入你的 U 盘</h2><p>先把你的移动硬盘插入到 mac 电脑上面</p><h2 id="在Finder中查看你的驱动器名称"><a href="#在Finder中查看你的驱动器名称" class="headerlink" title="在Finder中查看你的驱动器名称"></a>在Finder中查看你的驱动器名称</h2><p>左侧 位置 下面会显示你的 U 盘名称，记下它例如名字为： myDiskName</p><p>你也可以使用命令查看你的驱动器名称</p><p><code>df</code></p><p>或者</p><p><code>diskutil list</code></p><h2 id="更新-fstab-文件"><a href="#更新-fstab-文件" class="headerlink" title="更新 fstab 文件"></a>更新 fstab 文件</h2><p><code>sudo vim /etc/fstab</code></p><p>如果 vim 不会用，可以使用 <code>sudo nano /etc/fstab</code> 这个命令</p><p>把以下内容写入进去</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash">=myDiskName none ntfs rw,auto,nobrowse</span></span><br></pre></td></tr></table></figure><p><code>myDiskName</code> 这个是你的驱动器名称，记住别弄错了</p><h2 id="重新插入-U-盘"><a href="#重新插入-U-盘" class="headerlink" title="重新插入 U 盘"></a>重新插入 U 盘</h2><p>拔掉你的移动硬盘或优盘，再重新插入，这时你会发现找不到之前看到的那个驱动器了，这是正常的，按以下方法操作</p><ul><li>打开 Finder</li><li>使用快捷键 <code>Command+Shift+G</code></li><li>输入框中输入 <code>/Volumes</code></li><li>回车</li></ul><p>然后你就能看到你的磁盘了</p><p>方便起见，你可以直接把磁盘拖到Finder侧边栏中，这样下次使用就不用进入到/Volumes目录打开了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;默认情况下，把一个NTFS格式的磁盘插入到Mac里，是只能读不能写的。网上一直流传着这么一个简单的方法是用第三方工具，Paragon NTFS for MAC。但是要收费，第二就是破解版还不一定能运行。其实最早在OSX 10.5的时候，OSX其实原
      
    
    </summary>
    
      <category term="技术" scheme="https://leadscloud.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="macos" scheme="https://leadscloud.github.io/tags/macos/"/>
    
  </entry>
  
  <entry>
    <title>Visual Studio Code 内置终端的shell和字体设置成与 iterm2 一样</title>
    <link href="https://leadscloud.github.io/20190414/vs-code-intergrated-shell-setting/"/>
    <id>https://leadscloud.github.io/20190414/vs-code-intergrated-shell-setting/</id>
    <published>2019-04-14T03:10:21.000Z</published>
    <updated>2019-08-08T04:28:09.368Z</updated>
    
    <content type="html"><![CDATA[<p>macos下面的终端设置成了 iterm2.app </p><p><img src="/wp-content/media/15552120055438.jpg" alt></p><p>但 Visual Studio Code 的内置终端还是原来的，导致一些字体图标显示为乱码，如果想让它与 iterm2设置的一样，需要进行以下操作：</p><p><img src="/wp-content/media/15552118638003.jpg" alt></p><h3 id="下载powerline等宽字体"><a href="#下载powerline等宽字体" class="headerlink" title="下载powerline等宽字体"></a>下载powerline等宽字体</h3><p>任意目录下载字体</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/abertsch/</span>Menlo-<span class="keyword">for</span>-Powerline.git</span><br></pre></td></tr></table></figure><p>找到这几个字体，双击安装即可。</p><h3 id="设置settings-json"><a href="#设置settings-json" class="headerlink" title="设置settings.json"></a>设置settings.json</h3><p>添加如下几行</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"terminal.integrated.shell.osx"</span>: <span class="string">"/bin/zsh"</span>,</span><br><span class="line"><span class="string">"terminal.integrated.fontFamily"</span>: <span class="string">"Menlo for Powerline"</span></span><br></pre></td></tr></table></figure><p>如果希望终端中运行iTerm2，再添加如下两行</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"terminal.explorerKind"</span>: <span class="string">"external"</span>,</span><br><span class="line"><span class="string">"terminal.external.osxExec"</span>: <span class="string">"iTerm.app"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;macos下面的终端设置成了 iterm2.app &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/wp-content/media/15552120055438.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;但 Visual Studio Code 的内置终端还是原来的，导致一些字体图标显示为
      
    
    </summary>
    
      <category term="技术" scheme="https://leadscloud.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iterm" scheme="https://leadscloud.github.io/tags/iterm/"/>
    
  </entry>
  
  <entry>
    <title>git commit提交emoji的小工具及 git commit 规范</title>
    <link href="https://leadscloud.github.io/201904142/git-emoji-tools-and-git-commit-rules/"/>
    <id>https://leadscloud.github.io/201904142/git-emoji-tools-and-git-commit-rules/</id>
    <published>2019-04-14T03:10:21.000Z</published>
    <updated>2019-08-08T04:28:09.360Z</updated>
    
    <content type="html"><![CDATA[<p>编写提交 git commit 信息时轻松插入 emoji 的小工具</p><p><img src="https://cloud.githubusercontent.com/assets/7629661/20454643/11eb9e40-ae47-11e6-90db-a1ad8a87b495.gif" alt></p><p>小工具地址：</p><ul><li><a href="https://github.com/carloscuesta/gitmoji-cli" target="_blank" rel="noopener">https://github.com/carloscuesta/gitmoji-cli</a> </li></ul><h3 id="Git-commit日志基本规范"><a href="#Git-commit日志基本规范" class="headerlink" title="Git commit日志基本规范"></a>Git commit日志基本规范</h3><pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt;</code></pre><p>对格式的说明如下：</p><ul><li>type代表某次提交的类型，比如是修复一个bug还是增加一个新的feature。所有的type类型如下：</li><li>feat： 新增feature</li><li>fix: 修复bug</li><li>docs: 仅仅修改了文档，比如README, CHANGELOG, CONTRIBUTE等等</li><li>style: 仅仅修改了空格、格式缩进、都好等等，不改变代码逻辑</li><li>refactor: 代码重构，没有加新功能或者修复bug</li><li>perf: 优化相关，比如提升性能、体验</li><li>test: 测试用例，包括单元测试、集成测试等</li><li>chore: 改变构建流程、或者增加依赖库、工具等</li><li>revert: 回滚到上一个版本</li></ul><p>格式要求：</p><pre><code># 标题行：50个字符以内，描述主要变更内容## 主体内容：更详细的说明文本，建议72个字符以内。 需要描述的信息包括:## * 为什么这个变更是必须的? 它可能是用来修复一个bug，增加一个feature，提升性能、可靠性、稳定性等等# * 他如何解决这个问题? 具体描述解决问题的步骤# * 是否存在副作用、风险? ## 尾部：如果需要的化可以添加一个链接到issue地址或者其它文档，或者关闭某个issue。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;编写提交 git commit 信息时轻松插入 emoji 的小工具&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/7629661/20454643/11eb9e40-ae47-11e6-90db-a
      
    
    </summary>
    
      <category term="技术" scheme="https://leadscloud.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="git" scheme="https://leadscloud.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>关于域名抢注的一些事</title>
    <link href="https://leadscloud.github.io/20190413/domain-backorder/"/>
    <id>https://leadscloud.github.io/20190413/domain-backorder/</id>
    <published>2019-04-13T13:25:21.000Z</published>
    <updated>2019-08-08T04:28:09.360Z</updated>
    
    <content type="html"><![CDATA[<h3 id="寻找即将过期的域名"><a href="#寻找即将过期的域名" class="headerlink" title="寻找即将过期的域名"></a>寻找即将过期的域名</h3><p><a href="https://member.expireddomains.net/domains/pendingdelete/" target="_blank" rel="noopener">https://member.expireddomains.net/domains/pendingdelete/</a> </p><h3 id="我可以自己抢注吗？"><a href="#我可以自己抢注吗？" class="headerlink" title="我可以自己抢注吗？"></a>我可以自己抢注吗？</h3><p>自己抢注当然可以，一般是利用一些平台的 api,但成功率其实相当低，除非这些域名没什么人抢注。如果一个域名特别热门，不建议自己抢注，几乎不可能成功。</p><p>对于一些不太热门的域名抢注有几个注意事项：</p><ul><li>选择顶级的域名注册商，而不是代理商</li><li>注意注册商的 API 请求限制，尽量多注册几个账号，避免超过限制</li><li>先把离注册商服务器近的服务器来注册</li><li>定时更新你的服务器时间</li></ul><h3 id="提供域名抢注的一些平台"><a href="#提供域名抢注的一些平台" class="headerlink" title="提供域名抢注的一些平台"></a>提供域名抢注的一些平台</h3><ul><li><a href="https://www.catchtiger.com/en/" target="_blank" rel="noopener">CatchTiger</a>(.NL, .BE, .EU, .UK, .FR, .CH, .IT .LI) – €25</li><li><a href="http://www.namejet.com/Pages/Services/Backorders.aspx" target="_blank" rel="noopener">NameJet</a> – $79</li><li><a href="https://www.snapnames.com/" target="_blank" rel="noopener">SnapNames</a> – $79</li><li><a href="https://www.dropcatch.com/" target="_blank" rel="noopener">DropCatch</a> – $59</li><li><a href="http://www.godaddy.com/domainaddon/domain-backorders.aspx" target="_blank" rel="noopener">GoDaddy</a> – $25</li><li><a href="http://www.pool.com/" target="_blank" rel="noopener">Pool</a> – $60</li><li><a href="https://www.backorderzone.com/" target="_blank" rel="noopener">Backorder Zone</a> – $50</li><li><a href="https://www.dynadot.com/market/backorder/" target="_blank" rel="noopener">DynaDot</a> – $15</li><li><a href="https://www.hexonet.net/backorders" target="_blank" rel="noopener">Hexonet</a> – $59</li><li><a href="https://www.pheenix.com/" target="_blank" rel="noopener">Pheenix</a> – $14</li><li><a href="https://nidoma.com/en/service/backorder" target="_blank" rel="noopener">Nidoma</a> (.IT &amp; .ES) – $33</li><li><a href="https://park.io/" target="_blank" rel="noopener">Park.io</a> (.IO, .LY, .ME, .TO, .SH, .AC, .VC, .GG, .JE) – $99</li></ul><h3 id="ICANN-公布的注册商列表"><a href="#ICANN-公布的注册商列表" class="headerlink" title="ICANN 公布的注册商列表"></a>ICANN 公布的注册商列表</h3><p><a href="https://www.icann.org/registrar-reports/accreditation-qualified-list.html" target="_blank" rel="noopener">https://www.icann.org/registrar-reports/accreditation-qualified-list.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;寻找即将过期的域名&quot;&gt;&lt;a href=&quot;#寻找即将过期的域名&quot; class=&quot;headerlink&quot; title=&quot;寻找即将过期的域名&quot;&gt;&lt;/a&gt;寻找即将过期的域名&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://member.expireddomains.net
      
    
    </summary>
    
      <category term="技术" scheme="https://leadscloud.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="域名抢注" scheme="https://leadscloud.github.io/tags/%E5%9F%9F%E5%90%8D%E6%8A%A2%E6%B3%A8/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 安装 python3 和 chrome headless 及 chromedriver</title>
    <link href="https://leadscloud.github.io/20190409/centos7-install-chrome-headless-and-chromedriver/"/>
    <id>https://leadscloud.github.io/20190409/centos7-install-chrome-headless-and-chromedriver/</id>
    <published>2019-04-09T11:31:21.000Z</published>
    <updated>2019-08-08T04:28:09.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CentOS-安装-python3和-chrome-及-chromedriver"><a href="#CentOS-安装-python3和-chrome-及-chromedriver" class="headerlink" title="CentOS 安装 python3和 chrome 及 chromedriver"></a>CentOS 安装 python3和 chrome 及 chromedriver</h1><h2 id="安装-Python3"><a href="#安装-Python3" class="headerlink" title="安装 Python3"></a>安装 Python3</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> epel-<span class="keyword">release</span></span><br><span class="line">yum <span class="keyword">install</span> python36</span><br></pre></td></tr></table></figure><h3 id="安装-pip3"><a href="#安装-pip3" class="headerlink" title="安装 pip3"></a>安装 pip3</h3><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">curl </span>-O <span class="string">https:</span>//<span class="string">bootstrap.</span><span class="string">pypa.</span><span class="string">io/</span><span class="built_in">get-pip.py</span></span><br><span class="line"><span class="built_in">python3</span> <span class="built_in">get-pip.py</span></span><br></pre></td></tr></table></figure><h2 id="安装-chrome"><a href="#安装-chrome" class="headerlink" title="安装 chrome"></a>安装 chrome</h2><p><a href="https://intoli.com/blog/installing-google-chrome-on-centos/" target="_blank" rel="noopener">https://intoli.com/blog/installing-google-chrome-on-centos/</a></p><h3 id="RHEL-CentOS-7-X-下安装方法"><a href="#RHEL-CentOS-7-X-下安装方法" class="headerlink" title="RHEL/CentOS 7.X 下安装方法"></a>RHEL/CentOS 7.X 下安装方法</h3><p>先查看你的系统版本<br><code>cat /etc/redhat-release</code></p><p>编辑文件 <code>/etc/yum.repos.d/google-chrome.repo</code></p><p><code>vi /etc/yum.repos.d/google-chrome.repo</code></p><p>里面的内容如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[google-chrome]</span></span><br><span class="line"><span class="attr">name</span>=google-chrome</span><br><span class="line"><span class="attr">baseurl</span>=http://dl.google.com/linux/chrome/rpm/stable/<span class="variable">$basearch</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">gpgkey</span>=https://dl-ssl.google.com/linux/linux_signing_key.pub</span><br></pre></td></tr></table></figure><p>完成安装</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> google-chrome-stable</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">google-chrome-stable <span class="params">--no-sandbox</span> <span class="params">--headless</span> <span class="params">--disable-gpu</span> <span class="params">--screenshot</span> https:<span class="string">//www.yahoo.com/</span></span><br></pre></td></tr></table></figure><h2 id="安装-chromedriver"><a href="#安装-chromedriver" class="headerlink" title="安装 chromedriver"></a>安装 chromedriver</h2><p>根据你的版本来安装</p><p><code>google-chrome --version</code> </p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>//chromedriver.chromium<span class="meta">.org</span>/downloads</span><br></pre></td></tr></table></figure><p>下载相应的版本后，解压，把 chromedriver 复制到<code>/usr/bin/</code></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cp</span> chromedriver /usr/bin/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CentOS-安装-python3和-chrome-及-chromedriver&quot;&gt;&lt;a href=&quot;#CentOS-安装-python3和-chrome-及-chromedriver&quot; class=&quot;headerlink&quot; title=&quot;CentOS 安装 py
      
    
    </summary>
    
      <category term="技术" scheme="https://leadscloud.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="chromedriver" scheme="https://leadscloud.github.io/tags/chromedriver/"/>
    
  </entry>
  
  <entry>
    <title>自动调整linux系统时间和时区与Internet时间同步</title>
    <link href="https://leadscloud.github.io/20190412/auto-update-centos-datetime/"/>
    <id>https://leadscloud.github.io/20190412/auto-update-centos-datetime/</id>
    <published>2019-04-09T11:31:21.000Z</published>
    <updated>2019-08-08T04:28:09.356Z</updated>
    
    <content type="html"><![CDATA[<p>简要分为以下3个方法：</p><h2 id="一、修改时区"><a href="#一、修改时区" class="headerlink" title="一、修改时区"></a>一、修改时区</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp <span class="regexp">/etc/</span>localtime <span class="regexp">/etc/</span>localtime.bak</span><br><span class="line">ln -svf <span class="regexp">/usr/</span>share<span class="regexp">/zoneinfo/</span>Asia<span class="regexp">/Shanghai /</span>etc<span class="regexp">/localtime</span></span><br></pre></td></tr></table></figure><h3 id="修改为中国的东八区"><a href="#修改为中国的东八区" class="headerlink" title="修改为中国的东八区"></a>修改为中国的东八区</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/sysconfig/clock</span><br><span class="line"><span class="attribute">ZONE</span>=<span class="string">"Asia/Shanghai"</span></span><br><span class="line"><span class="attribute">UTC</span>=<span class="literal">false</span></span><br><span class="line"><span class="attribute">ARC</span>=<span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="与时间服务器同步"><a href="#与时间服务器同步" class="headerlink" title="与时间服务器同步"></a>与时间服务器同步</h3><p>ntpdate 0.centos.pool.ntp.org</p><h2 id="二、配置新的时间"><a href="#二、配置新的时间" class="headerlink" title="二、配置新的时间"></a>二、配置新的时间</h2><p>日期设定：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -s <span class="number">2013</span>/<span class="number">09</span>/<span class="number">26</span></span><br></pre></td></tr></table></figure></p><p>时间设定：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">date</span> <span class="selector-tag">-s</span> 11<span class="selector-pseudo">:47</span><span class="selector-pseudo">:06</span></span><br><span class="line"># <span class="selector-tag">date</span> <span class="selector-tag">-s</span> "12<span class="selector-pseudo">:00</span><span class="selector-pseudo">:00</span> 2013<span class="selector-tag">-12-06</span>"</span><br><span class="line"># <span class="selector-tag">date</span> <span class="selector-tag">-s</span> "12<span class="selector-pseudo">:00</span><span class="selector-pseudo">:00</span> 20131206"</span><br><span class="line"># <span class="selector-tag">date</span> <span class="selector-tag">-s</span> "2013<span class="selector-tag">-12-06</span> 12<span class="selector-pseudo">:00</span><span class="selector-pseudo">:00"</span></span><br><span class="line"># <span class="selector-tag">date</span> <span class="selector-tag">-s</span> "20131206 12<span class="selector-pseudo">:00</span><span class="selector-pseudo">:00"</span></span><br></pre></td></tr></table></figure></p><blockquote><p><code>date</code> 是显示的系统OS时间<br><code>clock</code> 是显示Bios的时间</p></blockquote><p>查看硬件时间（BIOS的）：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hwclock [-rw]   </span><br><span class="line">  -r   查看现有<span class="keyword">BIOS时间，默认为－r参数</span></span><br><span class="line"><span class="keyword"> </span> -w   将现在的linux系统时间写入<span class="keyword">BIOS中</span></span><br><span class="line"><span class="keyword"> </span> -s   (systohc)将硬件时间调整为和目前的系统时间一样</span><br><span class="line"></span><br><span class="line"><span class="comment"># hwclock -s </span></span><br><span class="line"><span class="comment"># hwclock -w</span></span><br></pre></td></tr></table></figure><p> 当我们进行完 Linux 时间的校时后，还需要以 <code>hwclock -w</code> 来更新 BIOS 的时间，因为每次开机的时候，系统会重新由 BIOS 将时间读出来，所以，<em>BIOS 才是重要的时间依据</em>。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># hwclock</span><br><span class="line"><span class="number">2013</span>年<span class="number">09</span>月<span class="number">26</span>日 星期四 <span class="number">11</span>时<span class="number">49</span>分<span class="number">10</span>秒 <span class="number">-1.002805</span> seconds</span><br><span class="line">修改系统时间（date）后，要同步BIOS时钟，强制把系统时间写入CMOS：</span><br><span class="line"># clock -w </span><br><span class="line">或者</span><br><span class="line"># hwclock -w</span><br></pre></td></tr></table></figure><h2 id="三、实现Internet时间同步（这里可以忽略上面两步）"><a href="#三、实现Internet时间同步（这里可以忽略上面两步）" class="headerlink" title="三、实现Internet时间同步（这里可以忽略上面两步）"></a>三、实现Internet时间同步（这里可以忽略上面两步）</h2><h3 id="方法1-开机的时候自动网络校时-首先有自己的时间服务器-："><a href="#方法1-开机的时候自动网络校时-首先有自己的时间服务器-：" class="headerlink" title="方法1. 开机的时候自动网络校时(首先有自己的时间服务器)："></a>方法1. 开机的时候自动网络校时(首先有自己的时间服务器)：</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat /etc/rc.d/rc.local </span><br><span class="line">/usr/sbin/ntpdate -u <span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.3</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.4</span>;/sbin/hwclock -w</span><br></pre></td></tr></table></figure><p>后面的ip对应的是局域网内需要时间相同同步的主机。</p><h3 id="方法2-设定计划任务"><a href="#方法2-设定计划任务" class="headerlink" title="方法2. 设定计划任务"></a>方法2. 设定计划任务</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># yum -y install ntpdate # 安装时间同步命令</span></span><br><span class="line"><span class="section"># crontab -l(以下方法任选其一)</span></span><br><span class="line"><span class="emphasis">*/5 *</span> <span class="bullet">* *</span> * root ntpdate 210.72.145.44;hwclock -w #每隔半个小时与中国国家授时中心服务器同步一次时间</span><br><span class="line"><span class="emphasis">*/5 *</span> <span class="bullet">* *</span> * root ntpdate asia.pool.ntp.org;hwclock -w</span><br><span class="line"><span class="emphasis">*/5 *</span> <span class="bullet">* *</span> * root ntpdate 0.centos.pool.ntp.org;hwclock -w</span><br></pre></td></tr></table></figure><h2 id="手动和时间服务器校准时间："><a href="#手动和时间服务器校准时间：" class="headerlink" title="手动和时间服务器校准时间："></a>手动和时间服务器校准时间：</h2><h3 id="1-首先关闭ntpd服务："><a href="#1-首先关闭ntpd服务：" class="headerlink" title="1.首先关闭ntpd服务："></a>1.首先关闭ntpd服务：</h3><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># service ntpd stop</span></span><br></pre></td></tr></table></figure><h3 id="2-然后和时间服务器校准："><a href="#2-然后和时间服务器校准：" class="headerlink" title="2.然后和时间服务器校准："></a>2.然后和时间服务器校准：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">ntpdate</span> <span class="selector-tag">asia</span><span class="selector-class">.pool</span><span class="selector-class">.ntp</span><span class="selector-class">.org</span></span><br></pre></td></tr></table></figure><h3 id="3-同步BIOS时间："><a href="#3-同步BIOS时间：" class="headerlink" title="3.同步BIOS时间："></a>3.同步BIOS时间：</h3><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># hwclock -w</span></span><br></pre></td></tr></table></figure><h3 id="4-校准后然后开启ntpd服务"><a href="#4-校准后然后开启ntpd服务" class="headerlink" title="4.校准后然后开启ntpd服务"></a>4.校准后然后开启ntpd服务</h3><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># service ntpd start</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简要分为以下3个方法：&lt;/p&gt;
&lt;h2 id=&quot;一、修改时区&quot;&gt;&lt;a href=&quot;#一、修改时区&quot; class=&quot;headerlink&quot; title=&quot;一、修改时区&quot;&gt;&lt;/a&gt;一、修改时区&lt;/h2&gt;&lt;figure class=&quot;highlight awk&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
      <category term="技术" scheme="https://leadscloud.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="centos" scheme="https://leadscloud.github.io/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>LNMP MYSQL Error:The server quit without updating PID file</title>
    <link href="https://leadscloud.github.io/20190407/lnmp-mysql-start-error-quit-without-updating-pid-file/"/>
    <id>https://leadscloud.github.io/20190407/lnmp-mysql-start-error-quit-without-updating-pid-file/</id>
    <published>2019-04-02T11:40:41.000Z</published>
    <updated>2019-08-08T04:28:09.364Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Starting MySQL. ERROR! The server quit without updating PID file </p></blockquote><p>一般都是空间满了，磁盘空间不足导致无法写入，删除<code>mysql-bin.0000*</code>文件，在 <code>/usr/local/mysql/var</code> 目录下</p><p>磁盘空间充足的情况下还出现这个错误，试试以下办法</p><p>禁用 <code>bin-log</code></p><p><code>vi /etc/my.cnf</code></p><p>把以下注释下</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#log-bin=mysql-bin</span></span><br><span class="line"><span class="meta">#binlog_format=mixed</span></span><br></pre></td></tr></table></figure><p>保存，然后重新启动 mysql</p><p><code>/etc/init.d/mysql restart</code></p><h3 id="其它解决办法"><a href="#其它解决办法" class="headerlink" title="其它解决办法"></a>其它解决办法</h3><p>查看mysql进程，并结束 ps -ef | grep mysqld kill -[pid]  kill相应进程号</p><p>如果有其它情形，比如你对某些权限进行了设置，进行了其它操作，上网搜索，网上关于这个的解决方法很多，需要多尝试，大部分解决方案只针对特定情况。</p><p>我上面的解决办法，一般对于以下情景适用：</p><ul><li>使用的 lnmp 一键安装包</li><li>没有在服务器进行其它尝试，突然出现上面错误</li><li>之前是正常的</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Starting MySQL. ERROR! The server quit without updating PID file &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般都是空间满了，磁盘空间不足导致无法写入，删除&lt;code&gt;mysql-b
      
    
    </summary>
    
      <category term="技术" scheme="https://leadscloud.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="lnmp" scheme="https://leadscloud.github.io/tags/lnmp/"/>
    
  </entry>
  
  <entry>
    <title>MacOS 下解压文件遇到文件夹乱码解决办法</title>
    <link href="https://leadscloud.github.io/20190329/mac-unzip-Illegal-byte-sequence/"/>
    <id>https://leadscloud.github.io/20190329/mac-unzip-Illegal-byte-sequence/</id>
    <published>2019-03-29T11:40:41.000Z</published>
    <updated>2019-08-08T04:28:09.364Z</updated>
    
    <content type="html"><![CDATA[<p>解压 windows 下压缩的 zip 存档时，如果文件夹名包含中文，可能会出现以下错误</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">checkdir <span class="built_in">error</span>:  cannot <span class="built_in">create</span></span><br><span class="line">Illegal <span class="built_in">byte</span> sequence</span><br></pre></td></tr></table></figure><p>解决办法</p><p>用 ditto 代替 unzip</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">ditto</span> <span class="literal">-</span><span class="comment">V</span> <span class="literal">-</span><span class="comment">x</span> <span class="literal">-</span><span class="comment">k</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">sequesterRsrc</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">rsrc</span> <span class="comment">FILENAME</span><span class="string">.</span><span class="comment">ZIP</span> <span class="comment">DESTINATIONDIRECTORY</span></span><br></pre></td></tr></table></figure><p>BetterZip 也无法解决上面的问题，以上方法实测有效</p><p>solution: <a href="https://github.com/CocoaPods/CocoaPods/issues/7711" target="_blank" rel="noopener">https://github.com/CocoaPods/CocoaPods/issues/7711</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;解压 windows 下压缩的 zip 存档时，如果文件夹名包含中文，可能会出现以下错误&lt;/p&gt;
&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/s
      
    
    </summary>
    
      <category term="技术" scheme="https://leadscloud.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MacOS" scheme="https://leadscloud.github.io/tags/MacOS/"/>
    
  </entry>
  
  <entry>
    <title>寒冬之下，被cai的那些人到底去哪了？</title>
    <link href="https://leadscloud.github.io/20181230/2018-cold-winter-where-the-people-who-were-laid-off/"/>
    <id>https://leadscloud.github.io/20181230/2018-cold-winter-where-the-people-who-were-laid-off/</id>
    <published>2018-12-30T18:30:54.000Z</published>
    <updated>2019-08-08T04:28:09.356Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载这篇文章，内容不重要，就是记录下，都说2018是经济下行最严重的一年，虽然之前一直感受不到，但看到这么多文章，联想到自身，还是有点感受的，这两天在 v2ex 看到一篇文章，一个员工请假没一级领导批了，二级领导没有批，在网上发帖吐槽，CTO还回复，当然肯定都是骂 CTO的，生活不易，2018尤其是。 <a href="https://www.v2ex.com/t/522131" target="_blank" rel="noopener">https://www.v2ex.com/t/522131</a></p></blockquote><p>相信这个冬天，大家都看到了各种被cai和别名为『优化调整』的新闻。自从我发表《终于，这个冬天，我也被cai了》文章后，很多媒体和记者，每天都在加我微信，表示想做一些访谈，关于被cai人员的生活实录。当然我没有应允，一个是没有这么多时间，二个是公号就是对外的窗口，有什么想聊的，或者分享的，也会第一时间在公号同步，不想聊的，自然也不会再陈述。事情总是有聚集效应，很多被cai或优化的老铁，都被聚集到了我周围。一方面，大家处境一样，有共同点。二方面，可以彼此勉励下。索性这次就自己做了一次访谈实录，在征求他们同意后，我以实录方式，向大家还原被cai人员后的生活状态。为保证部分隐私，实录中访谈人均为化名。</p><h2 id="人物一：小A"><a href="#人物一：小A" class="headerlink" title="人物一：小A"></a>人物一：小A</h2><p>被cai时间：12中旬</p><p>年龄：24</p><p>那天我正在外面，手机上弹出几条消息，说的是：鱼哥，我刚刚被谈话了，然后进入了被cai名单中。赔偿是N+1，这个月就要签字走人了。目前有没有工作机会推荐？我说：先别慌，工作不要立马去找。先多准备准备。不然机会很容易浪费。小A在深圳，之前也是线下见过的。本科毕业2年了，在一家小公司做Android开发。老家是湖北的。女票是进公司后下手的。不过他们关系公开后，女票换了家公司，所以这次还好不是两人被cai，小A表示目前也是打算年后看机会的，现在相当于加速了他被动出去找工作。突然被抱出公司，被cai那几天很焦虑，虽然没有房贷、还有其他压力，但是感觉总是不太爽。我说，你这还年轻，出去分分钟找一份工作了，先好好准备，后面再投简历。最近一段时间，他都是在复习和准备。元旦后会开始尝试接触一些工作机会。小A表示女票还有家里人目前给他全力支持。他也有自信找一份好工作，毕竟也是打算年后换工作的。</p><h2 id="人物二：大B哥"><a href="#人物二：大B哥" class="headerlink" title="人物二：大B哥"></a>人物二：大B哥</h2><p>被cai时间：12上旬</p><p>年龄：37</p><p>相比于其他被cai的老铁而言，大B哥属于年纪稍大的。工作有10多年了，过去实际履历都是很不错，都是在大厂一线开发，后面36岁时，开始转向小公司做了一个小leader。当然这家公司已经过了C轮了。商业模式上其实算比较成熟。他过去是肩负一个全新的项目负责人，包括搭建团队，开发迭代产品。从去年11月开始到18年3月，几乎都是在招人，自己肩负一些开发工作。到12月，产品已经迭代了6个版本。眼看产品一天一天都在变好，相信过不久就可以给公司盈利。大B哥每次和我聊天，都老是让我帮他多推荐点人，项目缺人。并说公司靠谱，有前途，现金流充沛。他以后也不打算换工作，就把这个产品做好、做大、做强就行。是哇，愿景总是美好的，突然，12月上旬，公司宣布不再战略支持他这个项目了，因为快1年了，给公司带来收益不是太明显，管理层决定砍掉这个项目。并开始让大B哥通知他的下属这次优化调整。公司会按法律进行赔偿，大B哥说他当时第一个想到就是那个昨天刚入职的下属，好不容易把他从别的大厂挖角过来胡，今天让他去通知，这对他来说，有点说不出口，于是问，cai员计划是怎样的，HR告知他，是整个业务线都砍掉。也包括他自己。这对大B来说，有点接受不了，当场就反驳说：为什么不等到明年初再做这个决定？HR表示，这个是管理层做的决定，我们也不是太清楚。然后大B哥，去问他的领导，他领导说，互联网公司看的是盈利能力，短期无法盈利，就无法去讲故事忽悠投资人的钱，就无法拿到下一个风投。大B哥说，盈利从来不是一蹴而就的哇，然后负责人告诉他，公司老板就是靠投机主义者起家的，现在钱不好赚，只有节衣缩食才能过冬。这时大B内心一阵心寒，他想起了那个高大伟岸的老板，开会时总是说，兄弟们，我们有的是钱，我们会加大这个战略项目的投入。你们辛苦点，平时没事多加点班。年底了，给大家多发奖金。大B哥曾连续加班3个月，后来病倒了，在医院病床上还在完成关键模块开发。如今，老板一句话，所有努力付诸东流。大B哥说，他那时真有点想不开和想不通。说好的一起越快的玩耍呢。大B哥在这个年龄被cai，相比其他人来说，要挺的压力更大。比如他的房贷，老婆是全职太太，还有两个老人。因为年龄越大，机会越少，要求越高。这一点他是明白的。不过他说他这个年纪，还好认识很多人，人脉相比技能更重要，朋友得知他的情况后，很快就有联系到他，确实有些团队还缺一些负责人，加上他口碑不错，直接和老板聊好后。最近已经入职了某公司，可以说，也是有惊无险。</p><h2 id="人物三：小C"><a href="#人物三：小C" class="headerlink" title="人物三：小C"></a>人物三：小C</h2><p>被cai时间：12下旬</p><p>年龄：25</p><p>不同于小A和大B哥那样，小C可能没这么幸运了，他是国内某大厂被优化掉的一波。今年的应届刚毕业，上班还不到一年。他正是属于技术积累期，如今被cai后，他处于很被动。毕业以来，以为可以安安稳稳呆个几年。他说，他平时经常水群，口头说的最多的是，我厂这个很强，我厂那个很强，我厂就是牛逼，等等。他说，他曾经引以为豪的公司，现在对应届生也开闸刀，有点心寒。被cai的不只他一个应届生，过去在别人夸他在某厂时，他总是有很强的优越感。是啊，对于刚出社会的学生，加入大厂的确是一件引以为豪的事情。我告诉小C，我们这种工作有一定年限的人，实际上并不会care这些东西，大厂也好，小公司也罢，都是自己硬，才是最好的背书。我之前也面试一些大厂的，技术越厉害，其实和公司关联度越小。技术不是厉害，反而需要更多公司xx项目来衬托他。厉害的人，一定不是公司塑造的。当然离不开公司平台支持，这个毋庸置疑。小C说，自己目前有点不知所措。出来就是社招了，不是他过去那样参加应届生秋招和春招的身份。项目经验也不是很多。重新找工作，没有底。我说，你先梳理下自己知识，然后查漏补缺。也先多准备准备，过年还有30多天了，实在不行，明年上来再找。他担心明年上来，和他一样优化或者被cai的人会很多，同样岗位，面临竞争更激烈，想在年前敲定岗位。我举了个例子，今年房价这么高，每天还有那么多人在不动产中心交易。你是刚需，管他涨也好，跌也罢，有钱，就应该果断入手哇，没有什么可犹豫的。工作这个也是，岗位总是有的，多和少。你也是要有所储备，不然就是机会很多，一个也抓不住。所以当下，应该静下来总结总结。小C说，天越来越冷，一个人住在出租屋里，出门吃饭都懒的吃。买了一些馒头，将就啃着。我和小C说，我14年在北京连续啃馒头几个月，住几个人合租上下铺。最后不也找到工作了。小C表示，没有告知家里人，主要不想让家里人为自己担心，毕竟这么大的人了。最近很多公司快开年会了，小C电话告诉家里人说，他马上要参加他们公司的年会，到时人超级多，规模非常大，还有很多盛宴，到时发照片給看。他和我表示，自己也想感受一下大厂的年会氛围，毕竟工作第一年。如今只能在开年会那天，去朋友圈盗几张前同事发的图了。因为他说，在父母眼里，他是家里的骄傲。</p><h2 id="人物四：D哥"><a href="#人物四：D哥" class="headerlink" title="人物四：D哥"></a>人物四：D哥</h2><p>被cai时间：12中旬</p><p>年龄：30</p><p>D哥是在从传统行业半路转到开发上来的。在27岁时，参加了某马训练营培训，那时某马培训真是一个火热，出去人人都找到工作，个个薪资上w。所以D哥也这时参与到为期4个月培训中了，虽然学费1w多，但是老师说了，出去毕业分分钟就拿这么多工资，D哥说自己在传统行业，也就4000多块钱，长期干下去，即便当了小领导，也就6000-7000，所以他转型做IT。主要还是因为IT收入高。D哥是个能吃苦的人。他说自己在参加某马训练营资格考试时，每天学基础学到晚上2点多，白天早上起来继续学习。后来通过了某马训练营入学资格。在为期4个月学习时，他表示自己过去这么多年，都没有那么努力过，我理解，也许当一个人确实想改变自己时，再大的困难也会克服。后面4个月结束后，确实像某马宣传那样大家都找到了待遇不错的工作，当然班里部分同学是用假经验找到的，后面大家都真正工作后，就有了真实工作经验。但是也有不少人因为学历造假被公司直接开除也有，主要是部分公司必须要本科以上文凭，不得已，有些同学为了进去，但是却只有专科文凭，所以才弄了个假本科证。D哥说自己比较老实，去面试就直说自己半路转行的，学习和积累近一年，优点就是能抗压，学习能力强。当然大部分公司对于他这个说法，还是不感冒的，毕竟企业招人是干活的，尽量找的是有较多经验的人。但是他说，有一家初创公司接纳了他，他猜主要他对工资要求不是太高，为人比较老实和靠谱。初创公司前期也是摸石头过河。虽然没有班里其他人薪资高，但D哥很满足，毕竟这是转型的第一步。7800的月薪，让他已经对互联网充满信心。过了1年，他跳槽去一家中型企业了，因为觉得人总是要一步一步改变，这是我在D哥身上看到的。但是中型企业今年也过得很艰难。加上各方面对D哥的综合评价，虽然他努力，但是一些东西确实产出有限。在cai员指标名单中，自然也就有了他。当然他也直言不讳说，有部分原因也是职场潜规则导致。巴拉巴拉一堆。他目前表示，暂时先不找工作，先回家好好过个年。因为还要完成和对象结婚摆酒的喜事，要操办，明年过完年，再好好准备。摆酒的事情大于工作。D哥表示，工作过完年应该能找到，我都30岁了，娶媳妇生娃是头等大事。对于D哥，一路吃过苦、受过挫折过来的，尽管被cai了，我相信他内心早已经埋下韧性的种子。</p><p>听完了实录，很多人可能会思考，不同的人，不同经历，状态、看法，采取方式都是不同。我想这也许是构成了我们多彩的世界吧~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;转载这篇文章，内容不重要，就是记录下，都说2018是经济下行最严重的一年，虽然之前一直感受不到，但看到这么多文章，联想到自身，还是有点感受的，这两天在 v2ex 看到一篇文章，一个员工请假没一级领导批了，二级领导没有批，在网上发帖吐槽，CTO还回复
      
    
    </summary>
    
      <category term="转载" scheme="https://leadscloud.github.io/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="工作" scheme="https://leadscloud.github.io/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>中秋南京二日游</title>
    <link href="https://leadscloud.github.io/20180925/nanjing-travel/"/>
    <id>https://leadscloud.github.io/20180925/nanjing-travel/</id>
    <published>2018-09-25T13:19:33.000Z</published>
    <updated>2019-08-08T04:28:09.364Z</updated>
    
    <content type="html"><![CDATA[<p>去年今日，婚姻大事。今日已经又回到上海了，岁月流转，感觉时间越来越快了。毕竟不是孤身一人在上海了，有亲爱的老婆在身边，即使再远，也有守望的人。</p><p>三天假期，去了南京二天，一天逛了上海。节日的气氛不是很浓了，但月亮还是那么远。</p><p><img src="/wp-content/media/15386382178973.jpg" alt></p><p><img src="/wp-content/media/15386384757104.jpg" alt></p><hr><p><img src="/wp-content/media/15386391617814.jpg" alt></p><p>南京总统府如此之小，又如此之大，可以装的下整个政府系统。</p><p><img src="/wp-content/media/15386391872796.jpg" alt><br>明孝陵，的确可以称得上中国最大的还保存较好的陵墓，其实地面上的建筑也只有石头保存的较好，你能看到的任何一颗树都不会超过100年。</p><p><img src="/wp-content/media/15386393198949.jpg" alt><br>中山陵比孝陵的位置要高，连里面的石碑也要特意高过孝陵，以后任何人的墓也不能超过它。</p><p><img src="/wp-content/media/15386394798086.jpg" alt><br>南京博物院，里面有丰富的文物展示，比我去过的任何博物馆都多，即使是在北京也没见这么多过。</p><p>二天的时间看的匆匆忙忙，但避过了十一的人流高峰，终于是到了这个一直想来的城市。</p><p><img src="/wp-content/media/15386396697461.jpg" alt><br><img src="../wp-content/media/15386397317747.jpg" alt><br>上海的繁华还是挺美的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;去年今日，婚姻大事。今日已经又回到上海了，岁月流转，感觉时间越来越快了。毕竟不是孤身一人在上海了，有亲爱的老婆在身边，即使再远，也有守望的人。&lt;/p&gt;
&lt;p&gt;三天假期，去了南京二天，一天逛了上海。节日的气氛不是很浓了，但月亮还是那么远。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/
      
    
    </summary>
    
      <category term="个人日志" scheme="https://leadscloud.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="旅游" scheme="https://leadscloud.github.io/tags/%E6%97%85%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>[转载]再见JQuery，我的老朋友</title>
    <link href="https://leadscloud.github.io/20180830/goodbye-jquery/"/>
    <id>https://leadscloud.github.io/20180830/goodbye-jquery/</id>
    <published>2018-08-30T03:56:30.000Z</published>
    <updated>2019-08-08T04:28:09.360Z</updated>
    
    <content type="html"><![CDATA[<p>目前来说，随着html5的兴起，大部分网站已经可以抛弃jQuery了，但仍有部分行业是离不开它的，主要为了兼容IE浏览器，有很多的jQuery插件也导致它不太可能立即消失。</p><p>但对于大部分网站来说，不使用jQuery一样可以做到同样的效果，原生的JS目前已经可以和jQuery一样方便了。</p><p>我09年接触jQuery到现在也差不多快10年了，看着前端日新月异的变化，中间也错失了很多，在这缤纷变化的世界里，有时一旦不愿意接受变化，就会慢慢的被淘汰。很多3-5年的技术人员，还是一直用着jQuery，对于新的技术没有积极去学习尝试，导致离主流技术越来越远，自己的竞争力也在下降。</p><p>最近看到一篇关于jQuery的文章，jQuery的确过时了，虽然一时也不会死掉，但我们要看到这种趋势。</p><h3 id="Polyfill-io"><a href="#Polyfill-io" class="headerlink" title="Polyfill.io"></a>Polyfill.io</h3><p><strong>自动化的 JavaScript Polyfill 服务</strong></p><p>Polyfill 可以为旧浏览器提供和标准 API 一样的功能。比如你想要 IE 浏览器实现 Promise 和 fetch 功能，你需要手动引入 es6-promise、whatwg-fetch。而通过 Polyfill.io，你只需要引入一个 JS 文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.polyfill.io/v2/polyfill.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Polyfill.io 通过分析请求头信息中的 UserAgent 实现自动加载浏览器所需的 polyfills。</p><p>Polyfill.io 有一份默认功能列表，包括了最常见的 polyfills：document.querySelector、Element.classList、ES5 新增的 Array 方法、Date.now、ES6 中的 Object.assign、Promise 等。</p><p>你也可以通过传递 features 参数来自定义功能列表：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 加载 Promise&amp;fetch --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.polyfill.io/v2/polyfill.min.js?features=Promise,fetch"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 加载所有 ES5&amp;ES6 新特性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.polyfill.io/v2/polyfill.min.js?features=es5,es6"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Polyfill.io 还提供了其他 API，具体请查阅官方文档：</p><p>以下是原文：</p><pre><code>免责声明本文是仓促之作，从构思到成文不足半天。文中没有提到很多优秀的库和框架，提前在此致歉，因为没时间搜集整理。但这不代表笔者对这些库和框架没有敬意。实际上，包括jQuery在内，我的敬意是给这些名字背后整个社区和贡献者的，当然包括库和框架的最初编写者，比如John Resig。另外，时间所限，本文粗略、不严谨，甚至可能不客观地描绘了前端技术的发展脉络。对前端发展走向的这个判断，仅代表本人自己的主观认知，并非业界共识，恳请广大读者了解。千万不要以本文观点作为评价前端技术发展的依据。谢谢！作者：奇舞周刊链接：https://juejin.im/post/5b5af8565188251b186bcfcb来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre><h3 id="Github抛弃jQuery"><a href="#Github抛弃jQuery" class="headerlink" title="Github抛弃jQuery"></a>Github抛弃jQuery</h3><p>2018年7月25日，Mislav Marohnić发了一条推文，宣布GitHub.com前端已经彻底删除了jQuery（下图）。而且，还自问自答地解释（低调炫耀），删除jQuery之后也没用其他框架，而是全部依赖原生API。</p><p>很多人不知道，我和jQuery颇有渊源。大概11年前（2007年），因为“疯狂迷恋”jQuery，我在国内率先翻译了jQuery 1.1的文档。后来有同好基于我翻译的版本继续翻译了jQuery新版文档，还不忘记在“关于”中提到我（<a href="http://hemin.cn/jq/about.html）：" target="_blank" rel="noopener">http://hemin.cn/jq/about.html）：</a></p><p>居然称我为“国内jQuery的引路人”，惭愧。但在当时jQuery文档奇缺的情况下，我翻译的中文版应该是帮到了不少同学的。后来，我还翻译了Learning jQuery（《jQuery基础教程》）。<br>正因与jQuery的这个不解之缘，GitHub.com彻底抛弃jQuery的消息才触动我想了一些事。于是，决定写这篇小文，以飨读者（但愿有用，哈哈）。</p><h3 id="jQuery的辉煌"><a href="#jQuery的辉煌" class="headerlink" title="jQuery的辉煌"></a>jQuery的辉煌</h3><p>jQuery最初诞生于2006年8月，作者是John Resig（<a href="https://zh.wikipedia.org/wiki/JQuery）。10多年前，网页开发者（当时还没有“前端”这个概念）深受浏览器不兼容性之苦。以jQuery为代表的一批JavaScript库/框架应运而生：" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/JQuery）。10多年前，网页开发者（当时还没有“前端”这个概念）深受浏览器不兼容性之苦。以jQuery为代表的一批JavaScript库/框架应运而生：</a></p><ul><li>Dojo</li><li>jQuery</li><li>MooTools</li><li>Prototype</li><li>Yahoo! User Interface Library (YUI)</li><li>Script.aculo.us</li></ul><p>这些库有的像jQuery一样是主打通用性，比如Dojo、Prototype；有的则走更专业化的路线，比如YUI（组件化）和Script.aculo.us（动画交互）。从通用功能看，这些库大都提供了如下特性：</p><ul><li>语法糖：链式调用、实用函数</li><li>选择元素：基于各种标准选择符和库自定义的选择符，以及通过回调进行筛选</li><li>操作DOM：创建和操作元素，乃至各种属性操作</li><li>处理事件：ready事件及各种注册和触发事件的方法，乃至委托</li><li>动画：基于animate的CSS属性动画，以及内置动画方法</li><li>Ajax：封装原生的XMLHttpRequest API，简化请求方法及回调处理</li></ul><p>一批宣传和推广这些库和框架的书籍相继面世，迅速推动了这些库的采用。2010年出版的DOM Scripting, 2nd（《JavaScript DOM脚本编程艺术（第2版）》）就是其中之一。这本书专门有一个附录，介绍当时流行的库，主推jQuery。</p><p>当时jQuery官网的自我描述是这样的：</p><p>  “a fast and concise JavaScript Library that simplifies HTML document traversing, event handling, animating, and Ajax interactions for rapid web development. jQuery is designed to change the way that you write JavaScript.”</p><p>不错，正是这样。jQuery凭借其选择器方法、面向集合的链式调用、对事件和Ajax的完善支持、简单而强大的动效等独有优势，迅速风靡，成为几乎所有网站开发必备的JavaScript库，乃至开创了jQuery编程风格。</p><p>开发者选择jQuery的理由简单直接：</p><ul><li>跨浏览器</li><li>简单高效</li><li>稳定可靠</li><li>插件丰富</li></ul><p>2011年新版的“犀牛书”第6版——JavaScript: The Definitive Guide, 6th甚至拿出第19章整整64页篇幅隆重讲解了jQuery（“Chapter 19. The jQuery Library”）。</p><p>jQuery从此走向鼎盛和辉煌。后来，随着前端交互越来越重和移动应用的普及，jQuery UI、jQuery Mobile相继面世。</p><p>时至今日，jQuery仍然在支撑着数以千万计各种规模网站的运作——尽管聚光灯下已经不常看到她的身影。</p><h3 id="历史的选择"><a href="#历史的选择" class="headerlink" title="历史的选择"></a>历史的选择</h3><p>最近10年，是“前端行业”有史以来发展最快的10年。</p><p>移动社交时代的到来不仅没有让桌面Web失色，反倒刺激了Web标准的迅猛改进。HTML5不仅带来了极大的向后兼容性，也带来了更丰富的原生DOM API。CSS从CSS3开始走上模块化的快车道，文本样式、排版布局、媒体查询，各种新模块让人目不暇接。</p><p>各大主流浏览器也在快速跟进，Firefox、Chrome、Opera、Safari、IE乃至Edge，都在积极重构甚至重写内核，争做支持Web标准的“楷模”。在这个大背景下，各大互联网公司不断调高兼容的IE版本号，从8到9到10，再到11。</p><p>当然，还有ECMAScript语言标准。自从划时代的ES6（ECMAScript 2015）发布之后，JavaScript终于真正开始摆脱“玩具”语言的尴尬境地。更重要的，从ES6起，ECMAScript也进入了快速迭代、每年发一版的节奏。ES7、ES8，以及ES9，每次都会给这门语言注入更强大的语言特性。</p><p>与此同时，Node.js和Babel等服务端运行时及转译工具的出现，也让前端工程化，以及向传统工业级软件开发最佳实践靠拢的速度日益加快。</p><p>2012年，笔者在图灵社区翻译过一篇文章“JavaScript宝座：七大框架论剑”（<a href="http://www.ituring.com.cn/article/8108）。当时的“七大框架”是：" target="_blank" rel="noopener">http://www.ituring.com.cn/article/8108）。当时的“七大框架”是：</a></p><ul><li>Backbone</li><li>Knockout</li><li>Spine</li><li>CanJS</li><li>Ember</li><li>AngularJS</li><li>Batman</li><li>Meteor</li></ul><p>后来，谷歌主打SPA（Single Page Application，单页应用）的Angular终于一枝独秀。不久，脸书推出的“在JS里写HTML一样优雅”的React则一路高歌猛进。最终，集各家所长且简单易用的Vue横空出世。</p><p>前端开发已经从后“刀耕火种”时代的“农业文明”，逐渐进化为以大规模、可扩展、规范化、自动化为特征的准“工业文明”。<br>俗话说：“皮之不存，毛将焉附。”随着时代变迁、技术进步，jQuery赖以存在的环境正逐渐消失。如前所述，新的环境催生了一批框架新秀。曾经辉煌的jQuery终于走到了可以华丽谢幕的时刻。</p><h3 id="几句忠告"><a href="#几句忠告" class="headerlink" title="几句忠告"></a>几句忠告</h3><p>8年前，DOM Scripting, 2nd在推荐开发者使用前端库时，语重心长地说过下面这段话：</p><p>  “开发中使用库当然没问题，但前提是不要仅仅只知道怎么使用，更要知道它的工作原理。如果不能超越这些库，那在这些库变成你的拐杖之时，你也会随之“残废”。在使用某个库之前，一定要花时间学习掌握JavaScript和DOM。我们从一开头就强调“知其所以然”的重要性，告诉大家不能满足于仅仅“知其然”。如果使用了库，却不晓得其背后原理，无论对自己还是对产品都将是有害的。”</p><p>2012年，从后端转前端不久的Ray Nicholus接手了一个跨浏览器文件上传库（<a href="https://github.com/FineUploader）的维护和开发工作。他的第一反应就是用jQuery重写这个库。然而，用户反对引入任何对其他库的依赖。结果他只能使用原生浏览器的API。那又怎样呢？他发现，原来放弃jQuery的写法比自己想象的要容易。" target="_blank" rel="noopener">https://github.com/FineUploader）的维护和开发工作。他的第一反应就是用jQuery重写这个库。然而，用户反对引入任何对其他库的依赖。结果他只能使用原生浏览器的API。那又怎样呢？他发现，原来放弃jQuery的写法比自己想象的要容易。</a></p><p>2014年，Ray发表了：“You Don’t Need jQuery!”系列博客（<a href="https://blog.garstasio.com/you-dont-need-jquery/）。2016年，他的著作Beyond" target="_blank" rel="noopener">https://blog.garstasio.com/you-dont-need-jquery/）。2016年，他的著作Beyond</a> jQuery （Apress，<a href="https://www.amazon.com/dp/1484222342/）出版。Ray建议，学习前端开发，本来应该是这个顺序：" target="_blank" rel="noopener">https://www.amazon.com/dp/1484222342/）出版。Ray建议，学习前端开发，本来应该是这个顺序：</a></p><ol><li>学习JavaScript</li><li>学习Web API</li><li>学习jQuery（或其他框架/库）</li></ol><p>但很多人实际上是从#3开始的，然后过了很久才开始#1和#2（甚至从来没想过#1和#2）。结果就是“只知其然，而不知其所以然”。</p><p>如今，时移世易，jQuery即将谢幕，新一代组件化开发框架粉墨登场。然而，“太阳底下没有新鲜事。”不管是使用Angular，还是React，抑或是Vue，还是要真正理解它们背后的工作原理。<br>（为避免广告嫌疑，我在这里就不着重推荐360导航前端的刘博文同学即将出版的《深入浅出Vue.js》一书了，哈哈哈～～，因为没有封面可以展示。）</p><h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>jQuery作为第一代前端库的优秀代表，成就了今天Web的繁荣，也成就了一代Web开发者。作为“国内jQuery的引路人”（这个帽子是别人给的，我借用一下，哈哈），我个人对jQuery的感情是复杂的。既不希望它离开，又希望它早点离开。我想，这应该也是很多早期接触jQuery的前端开发者的心声吧。</p><p>作者：奇舞周刊<br>链接：<a href="https://juejin.im/post/5b5af8565188251b186bcfcb" target="_blank" rel="noopener">https://juejin.im/post/5b5af8565188251b186bcfcb</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前来说，随着html5的兴起，大部分网站已经可以抛弃jQuery了，但仍有部分行业是离不开它的，主要为了兼容IE浏览器，有很多的jQuery插件也导致它不太可能立即消失。&lt;/p&gt;
&lt;p&gt;但对于大部分网站来说，不使用jQuery一样可以做到同样的效果，原生的JS目前已经可以
      
    
    </summary>
    
      <category term="技术" scheme="https://leadscloud.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="jQuery" scheme="https://leadscloud.github.io/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>Javascript Hoisting 变量提升</title>
    <link href="https://leadscloud.github.io/20180731/javascript-hoisting/"/>
    <id>https://leadscloud.github.io/20180731/javascript-hoisting/</id>
    <published>2018-07-31T01:54:32.000Z</published>
    <updated>2019-08-08T04:28:09.360Z</updated>
    
    <content type="html"><![CDATA[<p>函数和变量的声明总是会被解析器悄悄地被“提升”到方法体的最顶部</p><p>上面是javascript变量提升的概念。为了更好地理解“变量提升”，我们先来看一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(foo);</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="string">"Javascript"</span>;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>控制台输出：undefined 为什么输出了undefined，而没有报错呢？</p><p>原来javascript是函数作用域，解析器会在函数开头处自动去声明局部变量，局部变量都会被放在函数的入口处定义，所以上面的代码实际会被解释成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">var</span> foo;</span><br><span class="line">    <span class="built_in">console</span>.log(foo);</span><br><span class="line">    foo = <span class="string">"Javascript"</span>;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>另外，需要注意Javascript中函数的两种声明方式存在的坑：</p><p>function fn(){} //函数声明式<br>var fn = function(){}; //函数表达式<br>对于函数声明式，解析器会确保在所有代码执行之前声明已经被解析。而对于函数表达式，与定义其它基本类型变量一样，逐句执行并解析。</p><p>我们再来举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数声明式 */</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">fn();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'来自函数声明式fn'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数表达式 */</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">fn();</span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'来自函数表达式fn'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>控制台依次输出：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">来自函数声明式fn</span><br><span class="line">fn is <span class="keyword">not</span> <span class="keyword">a</span> <span class="function"><span class="keyword">function</span></span></span><br></pre></td></tr></table></figure><p>可以看到，当使用函数声明的形式来定义函数时，可将调用语句写在函数声明之前，而后者，则会报错。</p><p>所以在Javascript中，变量的声明会被提升，而变量的赋值则不会。而函数的声明与变量的声明是不一样的，函数的函数体也会被一起提升，但请使用函数声明的形式才能提升。</p><p>原文: <a href="http://liaokeyu.com/%E6%8A%80%E6%9C%AF/2016/10/18/javascript_hoisting_%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87.html" target="_blank" rel="noopener">http://liaokeyu.com/%E6%8A%80%E6%9C%AF/2016/10/18/javascript_hoisting_%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;函数和变量的声明总是会被解析器悄悄地被“提升”到方法体的最顶部&lt;/p&gt;
&lt;p&gt;上面是javascript变量提升的概念。为了更好地理解“变量提升”，我们先来看一段代码：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;
      
    
    </summary>
    
      <category term="技术" scheme="https://leadscloud.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="javascript" scheme="https://leadscloud.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的匿名函数、闭包</title>
    <link href="https://leadscloud.github.io/20180730/javascript-closures/"/>
    <id>https://leadscloud.github.io/20180730/javascript-closures/</id>
    <published>2018-07-30T04:31:07.000Z</published>
    <updated>2019-08-08T04:28:09.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>匿名函数：就是没有函数名的函数。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通函数 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">box</span><span class="params">()</span> </span>&#123;               <span class="comment">//函数名是 box </span></span><br><span class="line">       <span class="keyword">return</span><span class="string">'Lee'</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名函数</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;               <span class="comment">//匿名函数，会报错</span></span><br><span class="line">     <span class="keyword">return</span><span class="string">'Lee'</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过表达式自我执行</span></span><br><span class="line"> (functionbox() &#123;            <span class="comment">//封装成表达式</span></span><br><span class="line">        alert(<span class="string">'Lee'</span>); </span><br><span class="line">&#125;)();                  <span class="comment">//()表示执行函数，并且传参</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//把匿名函数赋值给变量 </span></span><br><span class="line"><span class="keyword">var</span> box=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;            <span class="comment">//将匿名函数赋给变量 </span></span><br><span class="line">       <span class="keyword">return</span><span class="string">'Lee'</span>; </span><br><span class="line">&#125;;</span><br><span class="line"> alert(box());            <span class="comment">//调用方式和函数调用相似</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数里的匿名函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">box</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;                  <span class="comment">//函数里的匿名函数，产生闭包 </span></span><br><span class="line">        <span class="keyword">return</span><span class="string">'Lee'</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">alert(box()());               <span class="comment">//调用匿名函数</span></span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包的英文单词是closure，这是JavaScript中非常重要的一部分知识，因为使用闭包可以大大减少我们的代码量，使我们的代码看上去更加清晰等等，总之功能十分强大。</p><p>闭包的含义：闭包说白了就是函数的嵌套，内层的函数可以使用外层函数的所有变量，即使外层函数已经执行完毕（这点涉及JavaScript作用域链）。</p><p>使用闭包有一个优点，也是它的缺点：就是可以把局部变量驻留在内存中，可以避免使用全局变量。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name=<span class="string">'sun'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;     <span class="comment">//通过匿名函数返回 a() 局部变量 </span></span><br><span class="line">        <span class="keyword">return</span> name; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line">alert(a()());         <span class="comment">//通过a()()来直接调用匿名函数返回值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b=a();</span><br><span class="line">alert(b());          <span class="comment">//另一种调用匿名函数返回值</span></span><br></pre></td></tr></table></figure><p>匿名函数最大的用途是创建闭包（这是JavaScript语言的特性之一），并且还可以构建命名空间，以减少全局变量的使用。</p><h2 id="闭包的经典案例"><a href="#闭包的经典案例" class="headerlink" title="闭包的经典案例"></a>闭包的经典案例</h2><p>通过全局变量来累加</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num=<span class="number">0</span>;     <span class="comment">//全局变量 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">  num++;               <span class="comment">//模块级可以调用全局变量，进行累加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a();   <span class="comment">//1</span></span><br><span class="line">a();   <span class="comment">//2           //执行函数，累加了 </span></span><br><span class="line">alert(num);      <span class="comment">//输出全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num=<span class="number">0</span>;</span><br><span class="line">    num++;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">alert(a());         <span class="comment">//1</span></span><br><span class="line">alert(a());        <span class="comment">//1               //无法实现累加，因为局部变量又被初始化了</span></span><br></pre></td></tr></table></figure><p>每次调用，变量num都会被初始化，所以每次调用都会返回1而不是累加。我们可以用普通函数内部嵌套匿名函数，形成一个闭包来使变量驻留在内存中。</p><p>使用闭包进行累加</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b=a();      <span class="comment">//获得函数 </span></span><br><span class="line"></span><br><span class="line">alert(b());  <span class="comment">//1     //调用匿名函数 </span></span><br><span class="line">alert(b());  <span class="comment">//2      //第二次调用匿名函数，实现累加</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong> 闭包允许内层函数引用父函数中的变量，但是该变量是最终值</p><p>看下面的例子</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> * <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"> *     <span class="tag">&lt;<span class="name">li</span>&gt;</span>one<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> *     <span class="tag">&lt;<span class="name">li</span>&gt;</span>two<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> *     <span class="tag">&lt;<span class="name">li</span>&gt;</span>three<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> *     <span class="tag">&lt;<span class="name">li</span>&gt;</span>one<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> * <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">var lists = document.getElementsByTagName('li');</span><br><span class="line">for(var i = 0 , len = lists.length ; i <span class="tag">&lt; <span class="attr">len</span> ; <span class="attr">i</span>++)&#123;</span></span><br><span class="line"><span class="tag">    <span class="attr">lists</span>[<span class="attr">i</span>]<span class="attr">.onmouseover</span> = <span class="string">function()&#123;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">alert</span>(<span class="attr">i</span>);    </span></span><br><span class="line"><span class="tag">    &#125;;</span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure><p>你会发现当鼠标移过每一个<li>元素时，总是弹出4，而不是我们期待的元素下标。这是为什么呢？</li></p><p><strong>注意事项里已经讲了（最终值）。</strong></p><p>显然这种解释过于简单，当mouseover事件调用监听函数时，首先在匿名函数<code>(function(){ alert(i); })</code> 内部查找是否定义了 i，结果是没有定义；因此它会向上查找，查找结果是已经定义了，并且i的值是4（循环后的i值）；所以，最终每次弹出的都是4。</p><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var lists = document.getElementsByTagName(<span class="string">'li'</span>);</span><br><span class="line"><span class="keyword">for</span>(var <span class="built_in">i</span> = <span class="number">0</span> , len = lists.<span class="built_in">length</span> ; <span class="built_in">i</span> &lt; len ; <span class="built_in">i</span>++)&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span><span class="params">(index)</span>&#123;</span></span><br><span class="line">        lists[index].onmouseover = <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">            alert(index);    </span><br><span class="line">        &#125;;                    </span><br><span class="line">    &#125;)(<span class="built_in">i</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lists = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'li'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = lists.length; i &lt; len; i++)&#123;</span><br><span class="line">    lists[i].$$index = i;    <span class="comment">//通过在Dom元素上绑定$$index属性记录下标</span></span><br><span class="line">    lists[i].onmouseover = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.$$index);    </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决方案三"><a href="#解决方案三" class="headerlink" title="解决方案三"></a>解决方案三</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventListener</span><span class="params">(list, index)</span>&#123;</span></span><br><span class="line">    list.onmouseover = <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">        alert(index);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var lists = document.getElementsByTagName(<span class="string">'li'</span>);</span><br><span class="line"><span class="keyword">for</span>(var <span class="built_in">i</span> = <span class="number">0</span> , len = lists.<span class="built_in">length</span> ; <span class="built_in">i</span> &lt; len ; <span class="built_in">i</span>++)&#123;</span><br><span class="line">    eventListener(lists[<span class="built_in">i</span>] , <span class="built_in">i</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;匿名函数&quot;&gt;&lt;a href=&quot;#匿名函数&quot; class=&quot;headerlink&quot; title=&quot;匿名函数&quot;&gt;&lt;/a&gt;匿名函数&lt;/h2&gt;&lt;p&gt;匿名函数：就是没有函数名的函数。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;t
      
    
    </summary>
    
      <category term="技术" scheme="https://leadscloud.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="javascript" scheme="https://leadscloud.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>适用企业外贸推广的留言板询盘管理系统</title>
    <link href="https://leadscloud.github.io/20180615/google-seo-inquiry-messageboard/"/>
    <id>https://leadscloud.github.io/20180615/google-seo-inquiry-messageboard/</id>
    <published>2018-06-15T06:50:01.000Z</published>
    <updated>2019-08-08T04:28:09.360Z</updated>
    
    <content type="html"><![CDATA[<p>外贸营销留言板程序开源了！</p><p>Github 地址：</p><p><a href="https://github.com/leadscloud/inquiry" target="_blank" rel="noopener">https://github.com/leadscloud/inquiry</a></p><hr><p>一个简单的留言板程序，在外贸网站运行测试多年没有任何问题。如果你的公司没有留言板程序，或者现在需要去找一个简单的留言板程序，这个很适合你。</p><p>本人之前在矿山机械行业工作，给公司开发过留言板程序并且运行多年。 这几天我重新写了一个留言板程序，希望可以帮助广大做外贸的同行们。</p><p><strong>特点：</strong></p><ol><li>自动过滤垃圾留言信息</li><li>语言翻译功能集成</li><li>一键复制留言信息</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>把文件上传到服务器根目录</li><li>然后打开install.php, 例如： <a href="http://www.yourdomain.com/install.php" target="_blank" rel="noopener">http://www.yourdomain.com/install.php</a></li><li>安装完毕会在content目录下生成一个数据库</li></ol><h2 id="表单字段说明"><a href="#表单字段说明" class="headerlink" title="表单字段说明"></a>表单字段说明</h2><p>具体的字段设置你可以在系统根目录下的updata.php里查看。</p><p>姓名与邮箱是必填的，其它都是非必须的。</p><p>submit.html有一个示例文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"hidden"</span> <span class="attribute">name</span>=<span class="string">"from_company"</span> <span class="attribute">value</span>=<span class="string">"YourName"</span> /&gt;这个隐藏字段代表网站属于哪个牌子。</span><br><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"hidden"</span> <span class="attribute">name</span>=<span class="string">"referer"</span> <span class="attribute">value</span>=<span class="string">"http://www.youwantedsite.com"</span> /&gt;这个隐藏字段代表你强制把referer改为某个网站。</span><br></pre></td></tr></table></figure><p>字段：</p><p><code>name</code> <code>email</code> <code>title</code> <code>content</code> <code>country</code> <code>phone</code> <code>address</code> <code>from_company</code></p><h3 id="config-php-配置文件"><a href="#config-php-配置文件" class="headerlink" title="config.php 配置文件"></a>config.php 配置文件</h3><p>下面是config里的内容。请修改DB_NAME,务必要以.php结尾，防止下载。BING_TRANSLATE_KEY Bing的翻译API，可以去注册一个。Akismet_API_Key 反垃圾服务，wordpress的反垃圾插件就是用它。根据此系统的域名，注册一个。有问题，再联系我，上次调试是没问题的。QQ:75504026</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//database name</span></span><br><span class="line">define(<span class="string">'DB_NAME'</span>,<span class="string">'#inquiry_system.sqlite.php'</span>);</span><br><span class="line"><span class="comment">//database prefix</span></span><br><span class="line">define(<span class="string">'DB_PREFIX'</span>,<span class="string">'wp'</span>);</span><br><span class="line"><span class="comment">//bing translate api key</span></span><br><span class="line"><span class="comment">//define('ACCOUNT_KEY', 'nujIh3e7l8Xs8CkP44xTHwu4Gaw0vV1xzaSgXZy');  已废弃</span></span><br><span class="line">define(<span class="string">'BING_TRANSLATE_KEY'</span>, <span class="string">'7724d07b364645asdfds8ca7dfsds49624'</span>);</span><br><span class="line"><span class="comment">//Akismet API Key</span></span><br><span class="line">define(<span class="string">'Akismet_API_Key'</span>,<span class="string">'aaa7ab1s1df6e9'</span>);</span><br><span class="line"><span class="comment">//system root</span></span><br><span class="line">define(<span class="string">'BLOG_ROOT'</span>,dirname(<span class="keyword">__FILE__</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h2><p><img src="https://github.com/leadscloud/inquiry/blob/master/docs/inquiry-screen01.png?raw=true" alt></p><p><img src="https://github.com/leadscloud/inquiry/blob/master/docs/inquiry-screen02.png?raw=true" alt></p><p><img src="https://github.com/leadscloud/inquiry/blob/master/docs/inquiry-screen03.png?raw=true" alt></p><h2 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h2><p>QQ: 75504026</p><p>Email: <a href="mailto:love4026@gmail.com" target="_blank" rel="noopener">love4026@gmail.com</a></p><p>Website: <a href="https://leadscloud.github.io">https://leadscloud.github.io</a></p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h3 id="2018-4-19"><a href="#2018-4-19" class="headerlink" title="2018-4-19"></a>2018-4-19</h3><ul><li>bing翻译使用最新版本，去除之前的翻译</li><li>复制按钮使用原生的js即可，不用再使用flash技术了</li></ul><h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><p>留言板程序  简单留言板  外贸留言板  外贸营销  跨境电商留言板 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;外贸营销留言板程序开源了！&lt;/p&gt;
&lt;p&gt;Github 地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/leadscloud/inquiry&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/
      
    
    </summary>
    
      <category term="外贸推广" scheme="https://leadscloud.github.io/categories/%E5%A4%96%E8%B4%B8%E6%8E%A8%E5%B9%BF/"/>
    
    
      <category term="技术" scheme="https://leadscloud.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>你有技术焦虑吗？</title>
    <link href="https://leadscloud.github.io/20180524/do-you-have-technical-anxiety/"/>
    <id>https://leadscloud.github.io/20180524/do-you-have-technical-anxiety/</id>
    <published>2018-05-24T06:55:01.000Z</published>
    <updated>2019-08-08T04:28:09.360Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.v2ex.com/t/456479" target="_blank" rel="noopener">https://www.v2ex.com/t/456479</a><br>最近在V2EX上看到有人问，你有技术焦虑吗，提到现在各种技术迭代非常快，很多新兴的技术没有时间去了解。</p></blockquote><p>下面有一个的回复可以代表技术的更新速度之快</p><blockquote><p>相比前端，这些都是事？？？？<br>reacr, preact, omi, nest,<br>vue, nuxt,<br>webpack3, webpack4, parcel,<br>ng 全家桶,<br>ts, es678, 各种 polyfill,<br>scss/less/sass, cssnext, postcss, stylus.</p></blockquote><p>看到这些深有感触，我刚进入工作的时候那时候最多有个jQuery，现在前端和后端几乎没区别了。前端最开始只是html+css编写，现在是各种构建工具，而且一代比一代强，刚学会一个下一个新的工具又出来了。</p><p>到了我这个年纪，不光有技术、学习上的焦虑，应该还有中年焦虑，这应该是很多人都曾有的，工作8年，看到很多人离开，我还在原地，很多事情让我觉得有时能力是一方面，但选择往往很重要，很多时候选择决定了你的位置。</p><p>对于技术，有些是可以沉淀的，像技术原理、算法、数据结构这些，有些是更新变化很快，像前端的构建工具、CSS框架、JS框架。</p><p>我们常去做那些可以沉淀的事情，焦虑可以避免很多。</p><p>每个人到了一定年纪都会遇到那个年纪应该会出现的事情，比如离职、结婚、生育，不到那个阶段你根本体会不了什么感觉，生命是一步一步去体验经历的，焦虑也没有用，路总还是要跟着别人走一遍。</p><p>只要你有前进的动力，就会有”焦虑“，只要不影响到自己的生活，焦虑还是有一定好处的。无论何时，不放弃学习，就不用害怕。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.v2ex.com/t/456479&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.v2ex.com/t/456479&lt;/a&gt;&lt;br&gt;最近在V2EX上看到有人问，你有
      
    
    </summary>
    
      <category term="个人日志" scheme="https://leadscloud.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="技术" scheme="https://leadscloud.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>搜索引擎介绍Elasticsearch和Solr</title>
    <link href="https://leadscloud.github.io/20180419/search-engine-elasticsearch-vs-solr/"/>
    <id>https://leadscloud.github.io/20180419/search-engine-elasticsearch-vs-solr/</id>
    <published>2018-04-19T05:13:15.000Z</published>
    <updated>2019-08-08T04:28:09.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Elasticsearch简介"><a href="#Elasticsearch简介" class="headerlink" title="Elasticsearch简介"></a>Elasticsearch简介</h2><p>Elasticsearch是一个实时的分布式搜索和分析引擎。它可以帮助你用前所未有的速度去处理大规模数据。</p><p>它可以用于全文搜索，结构化搜索以及分析，当然你也可以将这三者进行组合。</p><p>Elasticsearch是一个建立在全文搜索引擎 Apache Lucene™ 基础上的搜索引擎，可以说Lucene是当今最先进，最高效的全功能开源搜索引擎框架。</p><p>但是Lucene只是一个框架，要充分利用它的功能，需要使用JAVA，并且在程序中集成Lucene。需要很多的学习了解，才能明白它是如何运行的，Lucene确实非常复杂。</p><p>Elasticsearch使用Lucene作为内部引擎，但是在使用它做全文搜索时，只需要使用统一开发好的API即可，而不需要了解其背后复杂的Lucene的运行原理。</p><p>当然Elasticsearch并不仅仅是Lucene这么简单，它不但包括了全文搜索功能，还可以进行以下工作:</p><ul><li>分布式实时文件存储，并将每一个字段都编入索引，使其可以被搜索。</li><li>实时分析的分布式搜索引擎。</li><li>可以扩展到上百台服务器，处理PB级别的结构化或非结构化数据。</li></ul><p>这么多的功能被集成到一台服务器上，你可以轻松地通过客户端或者任何你喜欢的程序语言与ES的RESTful API进行交流。</p><p>Elasticsearch的上手是非常简单的。它附带了很多非常合理的默认值，这让初学者很好地避免一上手就要面对复杂的理论，</p><p>它安装好了就可以使用了，用很小的学习成本就可以变得很有生产力。</p><p>随着越学越深入，还可以利用Elasticsearch更多高级的功能，整个引擎可以很灵活地进行配置。可以根据自身需求来定制属于自己的Elasticsearch。</p><p>使用案例：</p><ul><li>维基百科使用Elasticsearch来进行全文搜做并高亮显示关键词，以及提供search-as-you-type、did-you-mean等搜索建议功能。</li><li>英国卫报使用Elasticsearch来处理访客日志，以便能将公众对不同文章的反应实时地反馈给各位编辑。</li><li>StackOverflow将全文搜索与地理位置和相关信息进行结合，以提供more-like-this相关问题的展现。</li><li>GitHub使用Elasticsearch来检索超过1300亿行代码。</li><li>每天，Goldman Sachs使用它来处理5TB数据的索引，还有很多投行使用它来分析股票市场的变动。</li></ul><p>但是Elasticsearch并不只是面向大型企业的，它还帮助了很多类似DataDog以及Klout的创业公司进行了功能的扩展。</p><h3 id="Elasticsearch的优缺点"><a href="#Elasticsearch的优缺点" class="headerlink" title="Elasticsearch的优缺点"></a>Elasticsearch的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>Elasticsearch是分布式的。不需要其他组件，分发是实时的，被叫做”Push replication”。</li><li>Elasticsearch 完全支持 Apache Lucene 的接近实时的搜索。</li><li>处理多租户（multitenancy）不需要特殊配置，而Solr则需要更多的高级设置。</li><li>Elasticsearch 采用 Gateway 的概念，使得完备份更加简单。</li><li>各节点组成对等的网络结构，某些节点出现故障时会自动分配其他节点代替其进行工作。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>只有一名开发者（当前Elasticsearch GitHub组织已经不只如此，已经有了相当活跃的维护者）</li><li>还不够自动（不适合当前新的Index Warmup API）</li></ol><h2 id="Solr简介"><a href="#Solr简介" class="headerlink" title="Solr简介"></a>Solr简介</h2><p>Solr（读作“solar”）是Apache Lucene项目的开源企业搜索平台。其主要功能包括全文检索、命中标示、分面搜索、动态聚类、数据库集成，以及富文本（如Word、PDF）的处理。Solr是高度可扩展的，并提供了分布式搜索和索引复制。Solr是最流行的企业级搜索引擎，Solr4 还增加了NoSQL支持。</p><p>Solr是用Java编写、运行在Servlet容器（如 Apache Tomcat 或Jetty）的一个独立的全文搜索服务器。 Solr采用了 Lucene Java 搜索库为核心的全文索引和搜索，并具有类似REST的HTTP/XML和JSON的API。Solr强大的外部配置功能使得无需进行Java编码，便可对其进行调整以适应多种类型的应用程序。Solr有一个插件架构，以支持更多的高级定制。</p><p>因为2010年 Apache Lucene 和 Apache Solr 项目合并，两个项目是由同一个Apache软件基金会开发团队制作实现的。提到技术或产品时，Lucene/Solr或Solr/Lucene是一样的。</p><h3 id="Solr的优缺点"><a href="#Solr的优缺点" class="headerlink" title="Solr的优缺点"></a>Solr的优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol><li>Solr有一个更大、更成熟的用户、开发和贡献者社区。</li><li>支持添加多种格式的索引，如：HTML、PDF、微软 Office 系列软件格式以及 JSON、XML、CSV 等纯文本格式。</li><li>Solr比较成熟、稳定。</li><li>不考虑建索引的同时进行搜索，速度更快。</li></ol><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol><li>建立索引时，搜索效率下降，实时索引搜索效率不高。</li></ol><h2 id="Elasticsearch与Solr的比较"><a href="#Elasticsearch与Solr的比较" class="headerlink" title="Elasticsearch与Solr的比较"></a>Elasticsearch与Solr的比较</h2><p>当单纯的对已有数据进行搜索时，Solr更快。</p><p><img src="http://i.zhcy.tk/images/search_fresh_index_while_idle.png" alt></p><p>当实时建立索引时, Solr会产生io阻塞，查询性能较差, Elasticsearch具有明显的优势。</p><p><img src="http://i.zhcy.tk/images/search_fresh_index_while_indexing.png" alt></p><p>随着数据量的增加，Solr的搜索效率会变得更低，而Elasticsearch却没有明显的变化。</p><p><img src="http://i.zhcy.tk/images/search_fresh_index_while_indexing2.png" alt></p><p>综上所述，Solr的架构不适合实时搜索的应用。</p><h2 id="实际生产环境测试"><a href="#实际生产环境测试" class="headerlink" title="实际生产环境测试"></a>实际生产环境测试</h2><p>下图为将搜索引擎从Solr转到Elasticsearch以后的平均查询速度有了50倍的提升。</p><p><img src="http://i.zhcy.tk/images/average_execution_time.jpg" alt></p><h2 id="Elasticsearch-与-Solr-的比较总结"><a href="#Elasticsearch-与-Solr-的比较总结" class="headerlink" title="Elasticsearch 与 Solr 的比较总结"></a>Elasticsearch 与 Solr 的比较总结</h2><ul><li>二者安装都很简单；</li><li>Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能;</li><li>Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式；</li><li>Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供；</li><li>Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch。</li></ul><p>Solr 是传统搜索应用的有力解决方案，但 Elasticsearch 更适用于新兴的实时搜索应用。</p><h2 id="其他基于Lucene的开源搜索引擎解决方案"><a href="#其他基于Lucene的开源搜索引擎解决方案" class="headerlink" title="其他基于Lucene的开源搜索引擎解决方案"></a>其他基于Lucene的开源搜索引擎解决方案</h2><ul><li><p>直接使用 <a href="http://lucene.apache.org/" target="_blank" rel="noopener">Lucene</a></p><p>  说明：Lucene 是一个 JAVA 搜索类库，它本身并不是一个完整的解决方案，需要额外的开发工作。</p><p>  优点：成熟的解决方案，有很多的成功案例。apache 顶级项目，正在持续快速的进步。庞大而活跃的开发社区，大量的开发人员。它只是一个类库，有足够的定制和优化空间：经过简单定制，就可以满足绝大部分常见的需求；经过优化，可以支持 10亿+ 量级的搜索。</p><p>  缺点：需要额外的开发工作。所有的扩展，分布式，可靠性等都需要自己实现；非实时，从建索引到可以搜索中间有一个时间延迟，而当前的“近实时”(Lucene Near Real Time search)搜索方案的可扩展性有待进一步完善</p></li><li><p><a href="http://katta.sourceforge.net/" target="_blank" rel="noopener">Katta</a></p><p>  说明：基于 Lucene 的，支持分布式，可扩展，具有容错功能，准实时的搜索方案。</p><p>  优点：开箱即用，可以与 Hadoop 配合实现分布式。具备扩展和容错机制。</p><p>  缺点：只是搜索方案，建索引部分还是需要自己实现。在搜索功能上，只实现了最基本的需求。成功案例较少，项目的成熟度稍微差一些。因为需要支持分布式，对于一些复杂的查询需求，定制的难度会比较大。</p></li><li><p><a href="http://svn.apache.org/repos/asf/hadoop/mapreduce/trunk/src/contrib/index/README" target="_blank" rel="noopener">Hadoop contrib/index</a></p><p>  说明：Map/Reduce 模式的，分布式建索引方案，可以跟 Katta 配合使用。</p><p>  优点：分布式建索引，具备可扩展性。</p><p>  缺点：只是建索引方案，不包括搜索实现。工作在批处理模式，对实时搜索的支持不佳。</p></li><li><p><a href="http://sna-projects.com/" target="_blank" rel="noopener">LinkedIn 的开源方案</a></p><p>  说明：基于 Lucene 的一系列解决方案，包括 准实时搜索 zoie ，facet 搜索实现 bobo ，机器学习算法 decomposer ，摘要存储库 krati ，数据库模式包装 sensei 等等</p><p>  优点：经过验证的解决方案，支持分布式，可扩展，丰富的功能实现</p><p>  缺点：与 linkedin 公司的联系太紧密，可定制性比较差</p></li><li><p><a href="https://github.com/tjake/Lucandra" target="_blank" rel="noopener">Lucandra</a></p><p>  说明：基于 Lucene，索引存在 cassandra 数据库中</p><p>  优点：参考 cassandra 的优点</p><p>  缺点：参考 cassandra 的缺点。另外，这只是一个 demo，没有经过大量验证</p></li><li><p><a href="https://github.com/akkumar/hbasene" target="_blank" rel="noopener">HBasene</a></p><p>  说明：基于 Lucene，索引存在 HBase 数据库中</p><p>  优点：参考 HBase 的优点</p><p>  缺点：参考 HBase 的缺点。另外，在实现中，lucene terms 是存成行，但每个 term 对应的 posting lists 是以列的方式存储的。随着单个 term 的 posting lists 的增大，查询时的速度受到的影响会非常大</p></li></ul><p>原文： <a href="http://i.zhcy.tk/blog/elasticsearchyu-solr/" target="_blank" rel="noopener">http://i.zhcy.tk/blog/elasticsearchyu-solr/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Elasticsearch简介&quot;&gt;&lt;a href=&quot;#Elasticsearch简介&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch简介&quot;&gt;&lt;/a&gt;Elasticsearch简介&lt;/h2&gt;&lt;p&gt;Elasticsearch是一个实时
      
    
    </summary>
    
      <category term="转载" scheme="https://leadscloud.github.io/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="elasticsearch" scheme="https://leadscloud.github.io/tags/elasticsearch/"/>
    
      <category term="solr" scheme="https://leadscloud.github.io/tags/solr/"/>
    
  </entry>
  
</feed>
